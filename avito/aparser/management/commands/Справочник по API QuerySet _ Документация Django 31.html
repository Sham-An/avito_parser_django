






<html lang="ru" >
    <head>
        <meta charset="utf-8"/>
        <title>Справочник по API QuerySet | Документация Django 3.1 | Все о фреймворке Джанго и его библиотеках</title>
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta name="description" content="Справочник по API QuerySet¶ Этот документ описывает детали API QuerySet. Он основан на материале, представленном в руководствах модель и запросы к базе данных, так что вы, вероятно, захотите прочитать и понять эти документы, прежде чем читать этот. В этом справочнике …" />
        <meta name="yandex-verification" content="68f4641d7f454426" />
        <meta name="google-site-verification" content="9CW6iwITflBwNEW40QCIT5dW1dl7O0PCzXeXjYurY14" />
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
        <link rel="icon" type="image/png" href="/favicon.png">
        
        
        <link href="/static/css/df.css?1632467593" rel="stylesheet">
        
    
        
            
        
    
    <link rel="canonical" href="/docs/django/ru/3.2/ref/models/querysets/">
    
        
            
        
        <link rel="alternate"
            hreflang="ru"
            href="/docs/django/ru/3.1/ref/models/querysets/">
    
        
            
        
        <link rel="alternate"
            hreflang="en"
            href="/docs/django/en/3.1/ref/models/querysets/">
    






        <!-- Yandex.RTB -->
        <script>window.yaContextCb=window.yaContextCb||[]</script>
        <script src="https://yandex.ru/ads/system/context.js" async></script>
    </head>

    <body>

        <header class="df-header">
            <div class="df-header__content">
                <a class="df-header__brand" href="/">Django.fun</a>
                <span class="df-header__bar" id="df-nav-bar">&#9776;</span>

                <nav class="df-header__nav" id="df-nav">
                    <span class="df-header__nav__close" id="df-nav-close">✕</span>

                    <span>
                        <a href="/docs/">Документация
                            <svg xmlns="http://www.w3.org/2000/svg" width="5.019" height="8.623" viewBox="0 0 5.019 8.623">
                                <g transform="translate(-1481.168 -2218.188)">
                                    <path d="M230.571,368.7l3.958,3.958-3.958,3.958" transform="translate(1250.95 1849.842)" fill="none" stroke="#8497bc"></path>
                                </g>
                            </svg>
                        </a>
                        <div class="df-header__submenu">
                            <div class="df-header__submenu__content">
                                <div class="df-header__docs">
                                    <div class="df-header__docs__django">
                                        <h2><a href="/docs/django/ru/3.2/">Документация Django</a></h2>
                                        <p>Django (Джанго) — свободный фреймворк для веб-приложений на языке Python, использующий шаблон проектирования MVC. Проект поддерживается организацией Django Software Foundation.

Сайт на Django строится из одного или нескольких приложений, которые рекомендуется делать отчуждаемыми и подключаемыми. Это одно из существенных архитектурных отличий этого фреймворка от некоторых других (например, Ruby on Rails). Один из основных принципов фреймворка — DRY (англ. Don&#x27;t repeat yourself).

Также, в отличие от других фреймворков, обработчики URL в Django конфигурируются явно при помощи регулярных выражений.

Для работы с базой данных Django использует собственный ORM, в котором модель данных описывается классами Python, и по ней генерируется схема базы данных.</p>
                                        <div class="df-header__docs__django__versions">
                                            Выберите версию
                                            <div>
                                                
                                                    <a href="/docs/django/ru/dev/" title="Django dev">dev</a>
                                                
                                                    <a href="/docs/django/ru/3.2/" title="Django 3.2">3.2</a>
                                                
                                                    <a href="/docs/django/ru/3.1/" title="Django 3.1">3.1</a>
                                                
                                                    <a href="/docs/django/ru/2.2/" title="Django 2.2">2.2</a>
                                                
                                            </div>
                                        </div>
                                    </div>
                                    <div class="df-header__docs__libs">
                                        <h2><a href="/docs/">Документация Django библиотек</a></h2>
                                        <div class="df-header__docs__libs__content">
                                            
                                                <div>
                                                    <h3><a href="/docs/django-orm-cookbook/ru/2.0/">Рецепты Django ORM</a></h3>
                                                    <p>Рецепты Django ORM - это книга о работе с моделями Django ORM и Django. Django ORM является одним из ключевых столпов Django. Он предоставляет абстракции …</p>
                                                </div>
                                            
                                                <div>
                                                    <h3><a href="/docs/django-rest-framework/ru/3.12/">Django Rest Framework</a></h3>
                                                    <p>Django Rest Framework (DRF) — это библиотека, которая работает со стандартными моделями Django для создания гибкого и мощного API для проекта.</p>
                                                </div>
                                            
                                                <div>
                                                    <h3><a href="/docs/django-cms/ru/3.9/">Django CMS</a></h3>
                                                    <p>Django CMS - это современная платформа для веб-публикаций, построенная на Django, фреймворке веб-приложений «для перфекционистов с соблюдением сроков». Django CMS предлагает готовую поддержку общих функций, …</p>
                                                </div>
                                            
                                                <div>
                                                    <h3><a href="/docs/channels/ru/3/">Channels</a></h3>
                                                    <p>Channels - это проект, который использует Django и расширяет его возможности за пределы HTTP - для обработки WebSockets, протоколов чата, IoT-протоколов и многого другого. Он …</p>
                                                </div>
                                            
                                                <div>
                                                    <h3><a href="/docs/asgiref/ru/3/">ASGI — спецификация и утилиты</a></h3>
                                                    <p>ASGI (Asynchronous Server Gateway Interface) является духовным наследником WSGI, предназначенным для обеспечения стандартного интерфейса между асинхронными веб-серверами, платформами и приложениями Python. WSGI предоставил стандарт для …</p>
                                                </div>
                                            
                                                <div>
                                                    <h3><a href="/docs/social-docs/ru/0.1/">Python Social Auth</a></h3>
                                                    <p>Python Social Auth - это простой в настройке механизм социальной аутентификации/регистрации с поддержкой нескольких платформ и провайдеров аутентификации. Созданный с использованием базового кода из django-social-auth, …</p>
                                                </div>
                                            
                                        </div>
                                        <p><strong><a href="/docs/">Перейти к полному списке библиотек →</a></strong></p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </span>

                    <span>
                        <a href="/articles/">Статьи
                            <svg xmlns="http://www.w3.org/2000/svg" width="5.019" height="8.623" viewBox="0 0 5.019 8.623">
                                <g transform="translate(-1481.168 -2218.188)">
                                    <path d="M230.571,368.7l3.958,3.958-3.958,3.958" transform="translate(1250.95 1849.842)" fill="none" stroke="#8497bc"></path>
                                </g>
                            </svg>
                        </a>
                        <div class="df-header__submenu">
                            <div class="df-header__submenu__content">
                                <div class="df-header__docs__libs">
                                    <h2><a href="/articles/">Статьи о Django</a></h2>
                                    <div class="df-header__docs__libs__content">
                                        <div>
                                            <h3><a href="/news/">Новости</a></h3>
                                            <p>Новости Django. Будьте всегда в курсе последних изменений и событий.</p>
                                        </div>
                                        <div>
                                            <h3><a href="/tutorials/">Руководства</a></h3>
                                            <p>Учебники по фреймворку Django, его функциям, вариантам использования и общим полезным вещам фреймворка.</p>
                                        </div>
                                        <div>
                                            <h3><a href="/tips/">Советы</a></h3>
                                            <p>Различные маленькие подсказки, подсказки, необычное использование Django - небольшие полезные вещи.</p>
                                        </div>
                                        <div>
                                            <h3><a href="/videos/">Видео</a></h3>
                                            <p>Видеоуроки по фреймворку Django, основам и использованию Python и Django.</p>
                                        </div>
                                        <div></div>
                                        <div>
                                            <h3><a href="/python/">Python</a></h3>
                                            <p>Учебники по Python, его функциям, вариантам использования и общим полезным вещам.</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </span>


                    <span><a href="/qa/">Вопросы и ответы</a></span>

                    <span><a href="/ru/cbv/">Классы-представления Django</a></span>
                </nav>

            </div>
        </header>

        
    <div class="df-container">
        
        

<!-- Yandex.RTB R-A-395615-13 -->
<div id="yandex_rtb_R-A-395615-13"></div>
<script>window.yaContextCb.push(()=>{
  Ya.Context.AdvManager.render({
    renderTo: 'yandex_rtb_R-A-395615-13',
    blockId: 'R-A-395615-13'
  })
})</script>


        <div class="df-docs__doc sidebar-right">
            <div roles="sidebar">
                
    <div role="complementary">
    
        <h2><strong><a href="/docs/django/ru/3.1/">Django 3.1</a></strong></h2>
    
        
        


<!-- Yandex.RTB R-A-395615-3 -->
<div id="yandex_rtb_R-A-395615-3"></div>
<script type="text/javascript">
    (function(w, d, n, s, t) {
        w[n] = w[n] || [];
        w[n].push(function() {
            Ya.Context.AdvManager.render({
                blockId: "R-A-395615-3",
                renderTo: "yandex_rtb_R-A-395615-3",
                async: true
            });
        });
        t = d.getElementsByTagName("script")[0];
        s = d.createElement("script");
        s.type = "text/javascript";
        s.src = "//an.yandex.ru/system/context.js";
        s.async = true;
        t.parentNode.insertBefore(s, t);
    })(this, this.document, "yandexContextAsyncCallbacks");
</script>





    


        
            <h3>Содержание</h3>
            
                <ul>
<li><a class="reference internal" href="#">Справочник по API <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code></a><ul>
<li><a class="reference internal" href="#when-querysets-are-evaluated">Когда вычисляется <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code></a><ul>
<li><a class="reference internal" href="#pickling-querysets">Pickling <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#queryset-api"><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> API</a><ul>
<li><a class="reference internal" href="#methods-that-return-new-querysets">Методы, которые возвращают новый <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code></a><ul>
<li><a class="reference internal" href="#filter"><code class="docutils literal notranslate"><span class="pre">filter()</span></code></a></li>
<li><a class="reference internal" href="#exclude"><code class="docutils literal notranslate"><span class="pre">exclude()</span></code></a></li>
<li><a class="reference internal" href="#annotate"><code class="docutils literal notranslate"><span class="pre">annotate()</span></code></a></li>
<li><a class="reference internal" href="#order-by"><code class="docutils literal notranslate"><span class="pre">order_by()</span></code></a></li>
<li><a class="reference internal" href="#reverse"><code class="docutils literal notranslate"><span class="pre">reverse()</span></code></a></li>
<li><a class="reference internal" href="#distinct"><code class="docutils literal notranslate"><span class="pre">distinct()</span></code></a></li>
<li><a class="reference internal" href="#values"><code class="docutils literal notranslate"><span class="pre">values()</span></code></a></li>
<li><a class="reference internal" href="#values-list"><code class="docutils literal notranslate"><span class="pre">values_list()</span></code></a></li>
<li><a class="reference internal" href="#dates"><code class="docutils literal notranslate"><span class="pre">dates()</span></code></a></li>
<li><a class="reference internal" href="#datetimes"><code class="docutils literal notranslate"><span class="pre">datetimes()</span></code></a></li>
<li><a class="reference internal" href="#none"><code class="docutils literal notranslate"><span class="pre">none()</span></code></a></li>
<li><a class="reference internal" href="#all"><code class="docutils literal notranslate"><span class="pre">all()</span></code></a></li>
<li><a class="reference internal" href="#union"><code class="docutils literal notranslate"><span class="pre">union()</span></code></a></li>
<li><a class="reference internal" href="#intersection"><code class="docutils literal notranslate"><span class="pre">intersection()</span></code></a></li>
<li><a class="reference internal" href="#difference"><code class="docutils literal notranslate"><span class="pre">difference()</span></code></a></li>
<li><a class="reference internal" href="#select-related"><code class="docutils literal notranslate"><span class="pre">select_related()</span></code></a></li>
<li><a class="reference internal" href="#prefetch-related"><code class="docutils literal notranslate"><span class="pre">prefetch_related()</span></code></a></li>
<li><a class="reference internal" href="#extra"><code class="docutils literal notranslate"><span class="pre">extra()</span></code></a></li>
<li><a class="reference internal" href="#defer"><code class="docutils literal notranslate"><span class="pre">defer()</span></code></a></li>
<li><a class="reference internal" href="#only"><code class="docutils literal notranslate"><span class="pre">only()</span></code></a></li>
<li><a class="reference internal" href="#using"><code class="docutils literal notranslate"><span class="pre">using()</span></code></a></li>
<li><a class="reference internal" href="#select-for-update"><code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code></a></li>
<li><a class="reference internal" href="#raw"><code class="docutils literal notranslate"><span class="pre">raw()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#operators-that-return-new-querysets">Операторы, которые возвращают новый <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code></a><ul>
<li><a class="reference internal" href="#and">AND (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>)</a></li>
<li><a class="reference internal" href="#or">OR (<code class="docutils literal notranslate"><span class="pre">|</span></code>)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#methods-that-do-not-return-querysets">Методы, которые не возвращают <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code></a><ul>
<li><a class="reference internal" href="#get"><code class="docutils literal notranslate"><span class="pre">get()</span></code></a></li>
<li><a class="reference internal" href="#create"><code class="docutils literal notranslate"><span class="pre">create()</span></code></a></li>
<li><a class="reference internal" href="#get-or-create"><code class="docutils literal notranslate"><span class="pre">get_or_create()</span></code></a></li>
<li><a class="reference internal" href="#update-or-create"><code class="docutils literal notranslate"><span class="pre">update_or_create()</span></code></a></li>
<li><a class="reference internal" href="#bulk-create"><code class="docutils literal notranslate"><span class="pre">bulk_create()</span></code></a></li>
<li><a class="reference internal" href="#bulk-update"><code class="docutils literal notranslate"><span class="pre">bulk_update()</span></code></a></li>
<li><a class="reference internal" href="#count"><code class="docutils literal notranslate"><span class="pre">count()</span></code></a></li>
<li><a class="reference internal" href="#in-bulk"><code class="docutils literal notranslate"><span class="pre">in_bulk()</span></code></a></li>
<li><a class="reference internal" href="#iterator"><code class="docutils literal notranslate"><span class="pre">iterator()</span></code></a><ul>
<li><a class="reference internal" href="#with-server-side-cursors">С серверными курсорами</a></li>
<li><a class="reference internal" href="#without-server-side-cursors">Без серверных курсоров</a></li>
</ul>
</li>
<li><a class="reference internal" href="#latest"><code class="docutils literal notranslate"><span class="pre">latest()</span></code></a></li>
<li><a class="reference internal" href="#earliest"><code class="docutils literal notranslate"><span class="pre">earliest()</span></code></a></li>
<li><a class="reference internal" href="#first"><code class="docutils literal notranslate"><span class="pre">first()</span></code></a></li>
<li><a class="reference internal" href="#last"><code class="docutils literal notranslate"><span class="pre">last()</span></code></a></li>
<li><a class="reference internal" href="#aggregate"><code class="docutils literal notranslate"><span class="pre">aggregate()</span></code></a></li>
<li><a class="reference internal" href="#exists"><code class="docutils literal notranslate"><span class="pre">exists()</span></code></a></li>
<li><a class="reference internal" href="#update"><code class="docutils literal notranslate"><span class="pre">update()</span></code></a></li>
<li><a class="reference internal" href="#delete"><code class="docutils literal notranslate"><span class="pre">delete()</span></code></a></li>
<li><a class="reference internal" href="#as-manager"><code class="docutils literal notranslate"><span class="pre">as_manager()</span></code></a></li>
<li><a class="reference internal" href="#explain"><code class="docutils literal notranslate"><span class="pre">explain()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#field-lookups">Поиск <code class="docutils literal notranslate"><span class="pre">Field</span></code></a><ul>
<li><a class="reference internal" href="#exact"><code class="docutils literal notranslate"><span class="pre">exact</span></code></a></li>
<li><a class="reference internal" href="#iexact"><code class="docutils literal notranslate"><span class="pre">iexact</span></code></a></li>
<li><a class="reference internal" href="#contains"><code class="docutils literal notranslate"><span class="pre">contains</span></code></a></li>
<li><a class="reference internal" href="#icontains"><code class="docutils literal notranslate"><span class="pre">icontains</span></code></a></li>
<li><a class="reference internal" href="#in"><code class="docutils literal notranslate"><span class="pre">in</span></code></a></li>
<li><a class="reference internal" href="#gt"><code class="docutils literal notranslate"><span class="pre">gt</span></code></a></li>
<li><a class="reference internal" href="#gte"><code class="docutils literal notranslate"><span class="pre">gte</span></code></a></li>
<li><a class="reference internal" href="#lt"><code class="docutils literal notranslate"><span class="pre">lt</span></code></a></li>
<li><a class="reference internal" href="#lte"><code class="docutils literal notranslate"><span class="pre">lte</span></code></a></li>
<li><a class="reference internal" href="#startswith"><code class="docutils literal notranslate"><span class="pre">startswith</span></code></a></li>
<li><a class="reference internal" href="#istartswith"><code class="docutils literal notranslate"><span class="pre">istartswith</span></code></a></li>
<li><a class="reference internal" href="#endswith"><code class="docutils literal notranslate"><span class="pre">endswith</span></code></a></li>
<li><a class="reference internal" href="#iendswith"><code class="docutils literal notranslate"><span class="pre">iendswith</span></code></a></li>
<li><a class="reference internal" href="#range"><code class="docutils literal notranslate"><span class="pre">range</span></code></a></li>
<li><a class="reference internal" href="#date"><code class="docutils literal notranslate"><span class="pre">date</span></code></a></li>
<li><a class="reference internal" href="#year"><code class="docutils literal notranslate"><span class="pre">year</span></code></a></li>
<li><a class="reference internal" href="#iso-year"><code class="docutils literal notranslate"><span class="pre">iso_year</span></code></a></li>
<li><a class="reference internal" href="#month"><code class="docutils literal notranslate"><span class="pre">month</span></code></a></li>
<li><a class="reference internal" href="#day"><code class="docutils literal notranslate"><span class="pre">day</span></code></a></li>
<li><a class="reference internal" href="#week"><code class="docutils literal notranslate"><span class="pre">week</span></code></a></li>
<li><a class="reference internal" href="#week-day"><code class="docutils literal notranslate"><span class="pre">week_day</span></code></a></li>
<li><a class="reference internal" href="#iso-week-day"><code class="docutils literal notranslate"><span class="pre">iso_week_day</span></code></a></li>
<li><a class="reference internal" href="#quarter"><code class="docutils literal notranslate"><span class="pre">quarter</span></code></a></li>
<li><a class="reference internal" href="#time"><code class="docutils literal notranslate"><span class="pre">time</span></code></a></li>
<li><a class="reference internal" href="#hour"><code class="docutils literal notranslate"><span class="pre">hour</span></code></a></li>
<li><a class="reference internal" href="#minute"><code class="docutils literal notranslate"><span class="pre">minute</span></code></a></li>
<li><a class="reference internal" href="#second"><code class="docutils literal notranslate"><span class="pre">second</span></code></a></li>
<li><a class="reference internal" href="#isnull"><code class="docutils literal notranslate"><span class="pre">isnull</span></code></a></li>
<li><a class="reference internal" href="#regex"><code class="docutils literal notranslate"><span class="pre">regex</span></code></a></li>
<li><a class="reference internal" href="#iregex"><code class="docutils literal notranslate"><span class="pre">iregex</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#aggregation-functions">Агрегационные функции</a><ul>
<li><a class="reference internal" href="#expressions"><code class="docutils literal notranslate"><span class="pre">expressions</span></code></a></li>
<li><a class="reference internal" href="#output-field"><code class="docutils literal notranslate"><span class="pre">output_field</span></code></a></li>
<li><a class="reference internal" href="#aggregate-filter"><code class="docutils literal notranslate"><span class="pre">filter</span></code></a></li>
<li><a class="reference internal" href="#id7"><code class="docutils literal notranslate"><span class="pre">**extra</span></code></a></li>
<li><a class="reference internal" href="#avg"><code class="docutils literal notranslate"><span class="pre">Avg</span></code></a></li>
<li><a class="reference internal" href="#id8"><code class="docutils literal notranslate"><span class="pre">Count</span></code></a></li>
<li><a class="reference internal" href="#max"><code class="docutils literal notranslate"><span class="pre">Max</span></code></a></li>
<li><a class="reference internal" href="#min"><code class="docutils literal notranslate"><span class="pre">Min</span></code></a></li>
<li><a class="reference internal" href="#stddev"><code class="docutils literal notranslate"><span class="pre">StdDev</span></code></a></li>
<li><a class="reference internal" href="#sum"><code class="docutils literal notranslate"><span class="pre">Sum</span></code></a></li>
<li><a class="reference internal" href="#variance"><code class="docutils literal notranslate"><span class="pre">Variance</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#query-related-tools">Инструменты, связанные с запросами</a><ul>
<li><a class="reference internal" href="#q-objects"><code class="docutils literal notranslate"><span class="pre">Q()</span></code> объекты</a></li>
<li><a class="reference internal" href="#prefetch-objects">Объекты <code class="docutils literal notranslate"><span class="pre">Prefetch()</span></code></a></li>
<li><a class="reference internal" href="#prefetch-related-objects"><code class="docutils literal notranslate"><span class="pre">prefetch_related_objects()</span></code></a></li>
<li><a class="reference internal" href="#filteredrelation-objects">Объекты <code class="docutils literal notranslate"><span class="pre">FilteredRelation()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
        
    
        
            <h3>Extra</h3>
            <ul>
                
                    
                        <li><a href="/docs/django/ru/3.1/genindex/">Алфавитный указатель</a></li>
                    
                        <li><a href="/docs/django/ru/3.1/py-modindex/">Содержание модулей Python</a></li>
                    
                
            </ul>
        

        
        


<!-- Yandex.RTB R-A-395615-2 -->
<div id="yandex_rtb_R-A-395615-2"></div>
<script type="text/javascript">
    (function(w, d, n, s, t) {
        w[n] = w[n] || [];
        w[n].push(function() {
            Ya.Context.AdvManager.render({
                blockId: "R-A-395615-2",
                renderTo: "yandex_rtb_R-A-395615-2",
                async: true
            });
        });
        t = d.getElementsByTagName("script")[0];
        s = d.createElement("script");
        s.type = "text/javascript";
        s.src = "//an.yandex.ru/system/context.js";
        s.async = true;
        t.parentNode.insertBefore(s, t);
    })(this, this.document, "yandexContextAsyncCallbacks");
</script>


    </div>

                
            </div>
            <div role="main">
                
    <div id="version-switcher">
        <ul id="doc-languages" class="language-switcher">
            
                
            
                
                    <li class="other">
                        
                            
                        
                        <a href="/docs/django/en/3.1/ref/models/querysets/">en</a>
                    </li>
                
            
            <li class="current" title="Click on the links on the left to switch to another language.">
                    <span>Язык: <strong>ru</strong></span>
            </li>
        </ul>

        <ul id="doc-versions" class="version-switcher">
            
                
                    <li class="other">
                        
                            
                        
                        <a href="/docs/django/ru/dev/ref/models/querysets/">dev</a>
                    </li>
                
            
                
                    <li class="other">
                        
                            
                        
                        <a href="/docs/django/ru/3.2/ref/models/querysets/">3.2</a>
                    </li>
                
            
                
            
                
                    <li class="other">
                        
                            
                        
                        <a href="/docs/django/ru/2.2/ref/models/querysets/">2.2</a>
                    </li>
                
            
            <li class="current">
                <span>Версия:
                    <strong>3.1</strong>
                </span>
            </li>
        </ul>
    </div>
    
    
        
        <div id="docs-content">
            <div class="section" id="s-queryset-api-reference">
<span id="queryset-api-reference"></span><h1>Справочник по API <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code><a class="headerlink" href="#queryset-api-reference" title="Ссылка на этот заголовок">¶</a></h1>
<p>Этот документ описывает детали API <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>. Он основан на материале, представленном в руководствах <a class="reference internal" href="../../../topics/db/models/"><span class="doc">модель</span></a> и <a class="reference internal" href="../../../topics/db/queries/"><span class="doc">запросы к базе данных</span></a>, так что вы, вероятно, захотите прочитать и понять эти документы, прежде чем читать этот.</p>
<p>В этом справочнике мы будем использовать <a class="reference internal" href="../../../topics/db/queries/#queryset-model-example"><span class="std std-ref">пример моделей Weblog’а</span></a>, представленный в <a class="reference internal" href="../../../topics/db/queries/"><span class="doc">руководстве по запросам к базе данных</span></a>.</p>
<div class="section" id="s-when-querysets-are-evaluated">
<span id="s-id1"></span><span id="when-querysets-are-evaluated"></span><span id="id1"></span><h2>Когда вычисляется <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code><a class="headerlink" href="#when-querysets-are-evaluated" title="Ссылка на этот заголовок">¶</a></h2>
<p>Внутренне <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> может быть создан, отфильтрован, нарезан и, как правило, передан без фактического запроса к базе данных. На самом деле никаких действий с базой данных не происходит, пока вы не сделаете что-то для оценки набора запросов.</p>
<p>Вы можете вычислить <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> следующими способами:</p>
<ul>
<li><p class="first"><strong>Итерация.</strong> <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> является итеративным, и он выполняет свой запрос к базе данных при первой итерации по нему. Например, это напечатает заголовок всех записей в базе данных:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">headline</span><span class="p">)</span>
</pre></div>
</div>
<p>Примечание: не используйте это, если все, что вы хотите сделать, это определить, существует ли хотя бы один результат. Более эффективно использовать <a class="reference internal" href="#django.db.models.query.QuerySet.exists" title="django.db.models.query.QuerySet.exists"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exists()</span></code></a>.</p>
</li>
<li><p class="first"><strong>Срезы.</strong> Как объяснено в <a class="reference internal" href="../../../topics/db/queries/#limiting-querysets"><span class="std std-ref">Ограничение QuerySet</span></a>, <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> может быть нарезан, используя синтаксис Python для срезов массивов. Срез невычисленного <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> обычно возвращает другой невычисленный <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, но Django выполнит запрос к базе данных, если вы используете параметр «step» синтаксиса среза, и вернет список. Срез <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, который был вычислен, также возвращает список.</p>
<p>Также обратите внимание, что даже если срез невычисленного <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> возвращает другой невычисленный <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, дальнейшее его изменение (например, добавление дополнительных фильтров или изменение порядка) недопустимо, поскольку это плохо переводится в SQL и не будет иметь четкого значения.</p>
</li>
<li><p class="first"><strong>Pickling/Кэширование.</strong> См. следующий раздел для получения подробной информации о том, что происходит при <a class="reference internal" href="#pickling-querysets">pickling QuerySets</a>. Для целей этого раздела важно, чтобы результаты считывались из базы данных.</p>
</li>
<li><p class="first"><strong>repr().</strong> <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> вычисляется, когда вы вызываете <code class="docutils literal notranslate"><span class="pre">repr()</span></code> для него. Это удобно для интерактивного интерпретатора Python, поэтому вы можете сразу увидеть свои результаты при интерактивном использовании API.</p>
</li>
<li><p class="first"><strong>len().</strong> <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> вычисляется, когда вы вызываете <code class="docutils literal notranslate"><span class="pre">len()</span></code> для него. Это, как вы могли ожидать, возвращает длину списка результатов.</p>
<p>Примечание. Если вам нужно только определить количество записей в наборе (и вам не нужны фактические объекты), гораздо эффективнее обрабатывать количество на уровне базы данных, используя SQL <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">COUNT</span> <span class="pre">(*)</span></code>. Именно по этой причине Django предоставляет метод <a class="reference internal" href="#django.db.models.query.QuerySet.count" title="django.db.models.query.QuerySet.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code></a>.</p>
</li>
<li><p class="first"><strong>list().</strong> Принудительное вычисление <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> путем вызова <code class="docutils literal notranslate"><span class="pre">list()</span></code> для него. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">entry_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>bool().</strong> Тестирование <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> в логическом контексте, например, с использованием <code class="docutils literal notranslate"><span class="pre">bool()</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code>, <code class="docutils literal notranslate"><span class="pre">and</span></code> или оператора <code class="docutils literal notranslate"><span class="pre">if</span></code>, вызовет выполнение запроса. Если есть хотя бы один результат, <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> равен <code class="docutils literal notranslate"><span class="pre">True</span></code>, иначе <code class="docutils literal notranslate"><span class="pre">False</span></code>. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">if</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">&quot;Test&quot;</span><span class="p">):</span>
   <span class="nb">print</span><span class="p">(</span><span class="s">&quot;There is at least one Entry with the headline Test&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Примечание. Если вы хотите определить, существует ли хотя бы один результат (и вам не нужны реальные объекты), более эффективно использовать <a class="reference internal" href="#django.db.models.query.QuerySet.exists" title="django.db.models.query.QuerySet.exists"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exists()</span></code></a>.</p>
</li>
</ul>
<div class="df-ads">
        <!-- Yandex.RTB R-A-395615-4 -->
        <div id="yandex_rtb_R-A-395615-4"></div>
        <script type="text/javascript">
            (function(w, d, n, s, t) {
                w[n] = w[n] || [];
                w[n].push(function() {
                    Ya.Context.AdvManager.render({
                        blockId: "R-A-395615-4",
                        renderTo: "yandex_rtb_R-A-395615-4",
                        async: true
                    });
                });
                t = d.getElementsByTagName("script")[0];
                s = d.createElement("script");
                s.type = "text/javascript";
                s.src = "//an.yandex.ru/system/context.js";
                s.async = true;
                t.parentNode.insertBefore(s, t);
            })(this, this.document, "yandexContextAsyncCallbacks");
        </script>
    </div><div class="section" id="s-pickling-querysets">
<span id="s-id2"></span><span id="pickling-querysets"></span><span id="id2"></span><h3>Pickling <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code><a class="headerlink" href="#pickling-querysets" title="Ссылка на этот заголовок">¶</a></h3>
<p>Если вы используете <a class="reference external" href="https://docs.python.org/3/library/pickle.html#module-pickle" title="(в Python v3.9)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> для <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, это загрузит все результаты в память. Pickling обычно используется в качестве предвестника кеширования, и когда кешированный набор запросов перезагружается, вы хотите, чтобы результаты уже присутствовали и были готовы к использованию (чтение из базы данных может занять некоторое время, что отрицательно сказывается на цели кеширования). Это означает, что когда вы unpickle <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, он содержит результаты в тот момент, когда он был выбран, а не результаты, которые в данный момент находятся в базе данных.</p>
<p>Если вы хотите pickle только необходимую информацию для воссоздания <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> из базы данных позднее, выберите атрибут <code class="docutils literal notranslate"><span class="pre">query</span></code> для <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>. Затем вы можете воссоздать исходный <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> (без каких-либо результатов), используя код, подобный следующему:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">query</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>     <span class="c"># Assuming &#39;s&#39; is the pickled string.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qs</span> <span class="o">=</span> <span class="n">MyModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qs</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">query</span>            <span class="c"># Restore the original &#39;query&#39;.</span>
</pre></div>
</div>
<p>Атрибут <code class="docutils literal notranslate"><span class="pre">query</span></code> является непрозрачным объектом. Он представляет собой внутреннюю часть конструкции запроса и не является частью общедоступного API. Тем не менее, безопасно (и полностью поддерживается) pickle и unpickle содержимое атрибута, как описано здесь.</p>
<div class="admonition-you-can-t-share-pickles-between-versions admonition">
<p class="first admonition-title">Вы не можете использовать pickle между версиями</p>
<p>Соленья `` QuerySets`` действительны только для той версии Django, которая использовалась для их генерации. Если вы генерируете рассол с использованием Django версии N, нет никакой гарантии, что рассол будет читаем с Django версии N + 1. Соленые огурцы не должны использоваться как часть долгосрочной архивной стратегии.</p>
<p class="last">Так как ошибки совместимости с помощью pickle могут быть трудно диагностируемыми, например, незаметно поврежденные объекты, возникает <code class="docutils literal notranslate"><span class="pre">RuntimeWarning</span></code>, когда вы пытаетесь открепить набор запросов в версии Django, отличной от той, в которой он был выбран.</p>
</div>
</div>
</div>
<div class="section" id="s-queryset-api">
<span id="s-id3"></span><span id="queryset-api"></span><span id="id3"></span><h2><code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> API<a class="headerlink" href="#queryset-api" title="Ссылка на этот заголовок">¶</a></h2>
<p>Вот формальное объявление <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>:</p>
<dl class="py class">
<dt id="django.db.models.query.QuerySet">
<em class="property">class </em><code class="descname">QuerySet</code>(<em><span class="n">model</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">query</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">using</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">hints</span><span class="o">=</span><span class="default_value">None</span></em>)<a class="reference internal" href="../../../_modules/django/db/models/query/#QuerySet"><span class="viewcode-link">[исходный код]</span></a><a class="headerlink" href="#django.db.models.query.QuerySet" title="Ссылка на это определение">¶</a></dt>
<dd><p>Обычно, когда вы будете взаимодействовать с <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, вы будете использовать его <a class="reference internal" href="../../../topics/db/queries/#chaining-filters"><span class="std std-ref">фильтры цепочки</span></a>. Для этого большинство методов <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> возвращают новые наборы запросов. Эти методы подробно описаны ниже в этом разделе.</p>
<p>Класс <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> имеет два открытых атрибута, которые вы можете использовать для самоанализа:</p>
<dl class="py attribute">
<dt id="django.db.models.query.QuerySet.ordered">
<code class="descname">ordered</code><a class="headerlink" href="#django.db.models.query.QuerySet.ordered" title="Ссылка на это определение">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">True</span></code>, если <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> упорядочен - т.е. имеет <a class="reference internal" href="#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_by()</span></code></a> или сортировку по умолчанию для модели, иначе <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt id="django.db.models.query.QuerySet.db">
<code class="descname">db</code><a class="headerlink" href="#django.db.models.query.QuerySet.db" title="Ссылка на это определение">¶</a></dt>
<dd><p>База данных, которая будет использоваться, если этот запрос выполняется сейчас.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p class="last">Параметр <code class="docutils literal notranslate"><span class="pre">query</span></code> для <a class="reference internal" href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> существует для того, чтобы специализированные подклассы запросов могли реконструировать внутреннее состояние запроса. Значение параметра является непрозрачным представлением этого состояния запроса и не является частью общедоступного API.</p>
</div>
</dd></dl>

<div class="section" id="s-methods-that-return-new-querysets">
<div class="df-ads">
        <!-- Yandex.RTB R-A-395615-5 -->
        <div id="yandex_rtb_R-A-395615-5"></div>
        <script type="text/javascript">
            (function(w, d, n, s, t) {
                w[n] = w[n] || [];
                w[n].push(function() {
                    Ya.Context.AdvManager.render({
                        blockId: "R-A-395615-5",
                        renderTo: "yandex_rtb_R-A-395615-5",
                        async: true
                    });
                });
                t = d.getElementsByTagName("script")[0];
                s = d.createElement("script");
                s.type = "text/javascript";
                s.src = "//an.yandex.ru/system/context.js";
                s.async = true;
                t.parentNode.insertBefore(s, t);
            })(this, this.document, "yandexContextAsyncCallbacks");
        </script>
    </div><span id="methods-that-return-new-querysets"></span><h3>Методы, которые возвращают новый <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code><a class="headerlink" href="#methods-that-return-new-querysets" title="Ссылка на этот заголовок">¶</a></h3>
<p>Django предоставляет ряд методов уточнения <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, которые изменяют либо типы результатов, возвращаемых <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, либо способ выполнения его SQL-запроса.</p>
<div class="section" id="s-filter">
<span id="filter"></span><h4><code class="docutils literal notranslate"><span class="pre">filter()</span></code><a class="headerlink" href="#filter" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.filter">
<code class="descname">filter</code>(<em><span class="o">**</span><span class="n">kwargs</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.filter" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает новый <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, содержащий объекты, которые соответствуют заданным параметрам поиска.</p>
<p>Параметры поиска (<code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>) должны быть в формате, описанном в <a class="reference internal" href="#field-lookups"><span class="std std-ref">Поиск по полям</span></a> ниже. Несколько параметров объединяются через <code class="docutils literal notranslate"><span class="pre">И</span></code> в базовом операторе SQL.</p>
<p>Если вам нужно выполнить более сложные запросы (например, запросы с помощью операторов <code class="docutils literal notranslate"><span class="pre">OR</span></code>), вы можете использовать <a class="reference internal" href="#django.db.models.Q" title="django.db.models.Q"><code class="xref py py-class docutils literal notranslate"><span class="pre">Q</span> <span class="pre">objects</span></code></a>.</p>
</div>
<div class="section" id="s-exclude">
<span id="exclude"></span><h4><code class="docutils literal notranslate"><span class="pre">exclude()</span></code><a class="headerlink" href="#exclude" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.exclude">
<code class="descname">exclude</code>(<em><span class="o">**</span><span class="n">kwargs</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.exclude" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает новый <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, содержащий объекты, которые <em>не</em> соответствуют указанным параметрам поиска.</p>
<p>Параметры поиска (<code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>) должны быть в формате, описанном в <a class="reference internal" href="#field-lookups"><span class="std std-ref">Поиск по полям</span></a> ниже. Несколько параметров объединяются с помощью <code class="docutils literal notranslate"><span class="pre">AND</span></code> в базовом операторе SQL, и все это заключено в <code class="docutils literal notranslate"><span class="pre">NOT()</span></code>.</p>
<p>Этот пример исключает все записи, чье <code class="docutils literal notranslate"><span class="pre">pub_date</span></code> позже, чем 2005-1-3 И чьи <code class="docutils literal notranslate"><span class="pre">headline</span></code> равно «Hello»:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">pub_date__gt</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">headline</span><span class="o">=</span><span class="s">&#39;Hello&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>В терминах SQL это оценивается как:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span>
<span class="k">WHERE</span> <span class="k">NOT</span> <span class="p">(</span><span class="n">pub_date</span> <span class="o">&gt;</span> <span class="s1">&#39;2005-1-3&#39;</span> <span class="k">AND</span> <span class="n">headline</span> <span class="o">=</span> <span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>В этом примере исключаются все записи, чье <code class="docutils literal notranslate"><span class="pre">pub_date</span></code> позже, чем 2005-1-3 ИЛИ с заголовком «Hello»:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">pub_date__gt</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">&#39;Hello&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>В терминах SQL это оценивается как:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span>
<span class="k">WHERE</span> <span class="k">NOT</span> <span class="n">pub_date</span> <span class="o">&gt;</span> <span class="s1">&#39;2005-1-3&#39;</span>
<span class="k">AND</span> <span class="k">NOT</span> <span class="n">headline</span> <span class="o">=</span> <span class="s1">&#39;Hello&#39;</span>
</pre></div>
</div>
<p>Обратите внимание, что второй пример является более ограниченным.</p>
<p>Если вам нужно выполнить более сложные запросы (например, запросы с помощью операторов <code class="docutils literal notranslate"><span class="pre">OR</span></code>), вы можете использовать <a class="reference internal" href="#django.db.models.Q" title="django.db.models.Q"><code class="xref py py-class docutils literal notranslate"><span class="pre">Q</span> <span class="pre">objects</span></code></a>.</p>
</div>
<div class="df-ads">
    <!-- Yandex.RTB R-A-395615-6 -->
    <div id="yandex_rtb_R-A-395615-6"></div>
    <script type="text/javascript">
        (function(w, d, n, s, t) {
            w[n] = w[n] || [];
            w[n].push(function() {
                Ya.Context.AdvManager.render({
                    blockId: "R-A-395615-6",
                    renderTo: "yandex_rtb_R-A-395615-6",
                    async: true
                });
            });
            t = d.getElementsByTagName("script")[0];
            s = d.createElement("script");
            s.type = "text/javascript";
            s.src = "//an.yandex.ru/system/context.js";
            s.async = true;
            t.parentNode.insertBefore(s, t);
        })(this, this.document, "yandexContextAsyncCallbacks");
    </script>
    </div><div class="section" id="s-annotate">
<span id="annotate"></span><h4><code class="docutils literal notranslate"><span class="pre">annotate()</span></code><a class="headerlink" href="#annotate" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.annotate">
<code class="descname">annotate</code>(<em><span class="o">*</span><span class="n">args</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.annotate" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Аннотирует каждый объект в <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> с помощью предоставленного списка <a class="reference internal" href="../expressions/"><span class="doc">выражений запроса</span></a>. Выражение может быть простым значением, ссылкой на поле в модели (или любых связанных моделях) или агрегированным выражением (средние значения, суммы и т.д.), которое было вычислено для объектов, связанных с объектами в <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>.</p>
<p>Каждый аргумент <code class="docutils literal notranslate"><span class="pre">annotate()</span></code> является аннотацией, которая будет добавлена к каждому объекту в <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, который возвращается.</p>
<p>Функции агрегации, предоставляемые Django, описаны в <a class="reference internal" href="#aggregation-functions"><span class="std std-ref">Функции агрегации</span></a> ниже.</p>
<p>Аннотации, указанные с помощью ключевых аргументов, будут использовать ключевое слово в качестве псевдонима для аннотации. Для анонимных аргументов будет создан псевдоним, основанный на имени агрегатной функции и агрегируемого поля модели. Только агрегатные выражения, которые ссылаются на одно поле, могут быть анонимными аргументами. Все остальное должно быть ключевым аргументом.</p>
<p>Например, если вы манипулировали списком блогов, вы можете определить, сколько записей было сделано в каждом блоге:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="k">import</span> <span class="n">Count</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">Count</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">))</span>
<span class="go"># The name of the first blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;Blogasaurus&#39;</span>
<span class="go"># The number of entries on the first blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">entry__count</span>
<span class="go">42</span>
</pre></div>
</div>
<p>Модель <code class="docutils literal notranslate"><span class="pre">Blog</span></code> не определяет атрибут <code class="docutils literal notranslate"><span class="pre">entry__count</span></code> сама по себе, но с помощью ключевого аргумента для указания агрегатной функции вы можете контролировать имя аннотации:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">number_of_entries</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">))</span>
<span class="go"># The number of entries on the first blog, using the name provided</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">number_of_entries</span>
<span class="go">42</span>
</pre></div>
</div>
<p>Подробное обсуждение агрегации смотрите в <a class="reference internal" href="../../../topics/db/aggregation/"><span class="doc">руководство по агрегации</span></a>.</p>
</div>
<div class="section" id="s-order-by">
<span id="order-by"></span><h4><code class="docutils literal notranslate"><span class="pre">order_by()</span></code><a class="headerlink" href="#order-by" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.order_by">
<code class="descname">order_by</code>(<em><span class="o">*</span><span class="n">fields</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.order_by" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>По умолчанию результаты, возвращаемые <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, упорядочиваются с помощью кортежа, заданного параметром <code class="docutils literal notranslate"><span class="pre">ordering</span></code> в классе <code class="docutils literal notranslate"><span class="pre">Meta</span></code> модели. Вы можете переопределить это для каждого <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, используя метод <code class="docutils literal notranslate"><span class="pre">order_by</span></code>.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;-pub_date&#39;</span><span class="p">,</span> <span class="s">&#39;headline&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Приведенный выше результат будет упорядочен по убыванию <code class="docutils literal notranslate"><span class="pre">pub_date</span></code>, затем по возрастанию <code class="docutils literal notranslate"><span class="pre">headline</span></code>. Отрицательный знак перед <code class="docutils literal notranslate"><span class="pre">&quot;-pub_date&quot;</span></code> указывает <em>нисходящий</em> порядок. Восходящий порядок подразумевается. Чтобы упорядочить случайным образом, используйте <code class="docutils literal notranslate"><span class="pre">&quot;?&quot;</span></code>, например так:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;?&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Примечание: запросы <code class="docutils literal notranslate"><span class="pre">order_by('?')</span></code> могут быть дорогими и медленными, в зависимости от используемой вами базы данных.</p>
<p>Чтобы упорядочить по полю в другой модели, используйте тот же синтаксис, что и при запросах к отношениям модели. То есть имя поля, за которым следует двойное подчеркивание (<code class="docutils literal notranslate"><span class="pre">__</span></code>), за которым следует имя поля в новой модели и т.д. для всех моделей, к которым вы хотите присоединиться. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;blog__name&#39;</span><span class="p">,</span> <span class="s">&#39;headline&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Если вы попытаетесь упорядочить по полю, которое относится к другой модели, Django будет использовать упорядочение по умолчанию для связанной модели или упорядочить по первичному ключу связанной модели, если не указано <code class="xref py py-attr docutils literal notranslate"><span class="pre">Meta.ordering</span></code>. Например, поскольку модель <code class="docutils literal notranslate"><span class="pre">Blog</span></code> не имеет установленного порядка по умолчанию:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;blog&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>…идентично:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;blog__id&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Если бы <code class="docutils literal notranslate"><span class="pre">Blog</span></code> имел <code class="docutils literal notranslate"><span class="pre">ordering</span> <span class="pre">=</span> <span class="pre">['name']</span></code>, то первый набор запросов был бы идентичен:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;blog__name&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Вы также можете упорядочить <a class="reference internal" href="../expressions/"><span class="doc">выражения запроса</span></a>, вызвав <a class="reference internal" href="../expressions/#django.db.models.Expression.asc" title="django.db.models.Expression.asc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asc()</span></code></a> или <a class="reference internal" href="../expressions/#django.db.models.Expression.desc" title="django.db.models.Expression.desc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">desc()</span></code></a> в выражении:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Coalesce</span><span class="p">(</span><span class="s">&#39;summary&#39;</span><span class="p">,</span> <span class="s">&#39;headline&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">desc</span><span class="p">())</span>
</pre></div>
</div>
<p><a class="reference internal" href="../expressions/#django.db.models.Expression.asc" title="django.db.models.Expression.asc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">asc()</span></code></a> и <a class="reference internal" href="../expressions/#django.db.models.Expression.desc" title="django.db.models.Expression.desc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">desc()</span></code></a> имеют аргументы (<code class="docutils literal notranslate"><span class="pre">nulls_first</span></code> и <code class="docutils literal notranslate"><span class="pre">nulls_last</span></code>), которые управляют сортировкой нулевых значений.</p>
<p>Будьте осторожны при упорядочении по полям в связанных моделях, если вы также используете <code class="xref py py-meth docutils literal notranslate"><span class="pre">different()</span></code>. Смотрите примечания в <code class="xref py py-meth docutils literal notranslate"><span class="pre">different()</span></code> для объяснения того, как упорядочение связанной модели может изменить ожидаемые результаты.</p>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p>Допустимо указывать многозначное поле для упорядочения результатов по (например, полю a <a class="reference internal" href="../fields/#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> или обратному отношению <a class="reference internal" href="../fields/#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>).</p>
<p>Рассмотрим этот случай:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Event</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
   <span class="n">parent</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span>
       <span class="s">&#39;self&#39;</span><span class="p">,</span>
       <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">,</span>
       <span class="n">related_name</span><span class="o">=</span><span class="s">&#39;children&#39;</span><span class="p">,</span>
   <span class="p">)</span>
   <span class="n">date</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateField</span><span class="p">()</span>

<span class="n">Event</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;children__date&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Здесь потенциально могут быть данные о множественном упорядочении для каждого <code class="docutils literal notranslate"><span class="pre">события</span></code>; каждый <code class="docutils literal notranslate"><span class="pre">Event</span></code> с несколькими <code class="docutils literal notranslate"><span class="pre">children</span></code> будет возвращаться несколько раз в новый <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, который создает <code class="docutils literal notranslate"><span class="pre">order_by()</span></code>. Другими словами, использование <code class="docutils literal notranslate"><span class="pre">order_by()</span></code> в <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> может вернуть больше элементов, чем вы работали с самого начала - что, вероятно, ни ожидаемо, ни полезно.</p>
<p class="last">Таким образом, будьте осторожны при использовании многозначного поля для упорядочения результатов. <strong>Если</strong> вы можете быть уверены, что для каждого из заказываемых вами товаров будет только один фрагмент данных для заказа, такой подход не должен вызывать проблем. Если нет, убедитесь, что результаты соответствуют вашим ожиданиям.</p>
</div>
<p>Нет никакого способа указать, должна ли сортировка быть чувствительна к регистру. Что касается чувствительности к регистру, Django будет упорядочивать результаты, однако ваш сервер базы данных обычно упорядочивает их.</p>
<p>Вы можете сортировать по полю, преобразованному в нижний регистр, с помощью <a class="reference internal" href="../database-functions/#django.db.models.functions.Lower" title="django.db.models.functions.Lower"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lower</span></code></a>, что обеспечит последовательное упорядочение:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">Lower</span><span class="p">(</span><span class="s">&#39;headline&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">desc</span><span class="p">())</span>
</pre></div>
</div>
<p>Если вы не хотите, чтобы к запросу применялась какая-либо сортировка, даже по умолчанию, вызовите <a class="reference internal" href="#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_by()</span></code></a> без параметров.</p>
<p>Вы можете узнать, упорядочен запрос или нет, проверив атрибут <a class="reference internal" href="#django.db.models.query.QuerySet.ordered" title="django.db.models.query.QuerySet.ordered"><code class="xref py py-attr docutils literal notranslate"><span class="pre">QuerySet.ordered</span></code></a>, который будет <code class="docutils literal notranslate"><span class="pre">True</span></code>, если <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> был упорядочен каким-либо образом.</p>
<p>Каждый вызов <code class="docutils literal notranslate"><span class="pre">order_by()</span></code> очищает любую предыдущую сортировку. Например, этот запрос будет упорядочен <code class="docutils literal notranslate"><span class="pre">pub_date</span></code>, а не <code class="docutils literal notranslate"><span class="pre">headline</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;headline&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p>Сортировка не является «бесплатной» операцией. Каждое поле, которое вы добавляете к сортировке, добавляет нагрузку на базу данных. Каждый добавляемый вами внешний ключ также будет неявно включать все свои сортировки по умолчанию.</p>
<p class="last">Если в запросе не указан порядок, результаты возвращаются из базы данных в неуказанном порядке. Конкретное упорядочение гарантируется только при упорядочении с помощью набора полей, которые однозначно идентифицируют каждый объект в результатах. Например, если поле <code class="docutils literal notranslate"><span class="pre">name</span></code> не уникально, упорядочение по нему не гарантирует, что объекты с одинаковыми именами всегда будут появляться в одном и том же порядке.</p>
</div>
</div>
<div class="section" id="s-reverse">
<div class="df-ads">
    <!-- Yandex.RTB R-A-395615-7 -->
    <div id="yandex_rtb_R-A-395615-7"></div>
    <script type="text/javascript">
        (function(w, d, n, s, t) {
            w[n] = w[n] || [];
            w[n].push(function() {
                Ya.Context.AdvManager.render({
                    blockId: "R-A-395615-7",
                    renderTo: "yandex_rtb_R-A-395615-7",
                    async: true
                });
            });
            t = d.getElementsByTagName("script")[0];
            s = d.createElement("script");
            s.type = "text/javascript";
            s.src = "//an.yandex.ru/system/context.js";
            s.async = true;
            t.parentNode.insertBefore(s, t);
        })(this, this.document, "yandexContextAsyncCallbacks");
    </script>
    </div><span id="reverse"></span><h4><code class="docutils literal notranslate"><span class="pre">reverse()</span></code><a class="headerlink" href="#reverse" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.reverse">
<code class="descname">reverse</code>()<a class="headerlink" href="#django.db.models.query.QuerySet.reverse" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Используйте метод <code class="docutils literal notranslate"><span class="pre">reverse()</span></code> для изменения порядка, в котором возвращаются элементы набора запросов. Вызов <code class="docutils literal notranslate"><span class="pre">reverse()</span></code> во второй раз восстанавливает порядок в нормальном направлении.</p>
<p>Чтобы получить «последние» пять элементов в наборе запросов, вы можете сделать так:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">my_queryset</span><span class="o">.</span><span class="n">reverse</span><span class="p">()[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>Обратите внимание, что это не совсем то же самое, что вырезание из конца последовательности в Python. В приведенном выше примере сначала будет возвращен последний элемент, затем предпоследний элемент и т.д. Если бы у нас была последовательность Python и мы посмотрели на <code class="docutils literal notranslate"><span class="pre">seq[-5:]</span></code>, мы бы увидели пятый (последний) элемент первым. Django не поддерживает этот режим доступа (нарезка с конца), потому что это невозможно сделать эффективно в SQL.</p>
<p>Кроме того, обратите внимание, что <code class="docutils literal notranslate"><span class="pre">reverse()</span></code> обычно следует вызывать только для <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, который имеет определенную сортировку (например, при запросе к модели, которая определяет сортировку по умолчанию, или при использовании <a class="reference internal" href="#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_by()</span></code></a>). Если такая сортировка не определена для данного <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, то вызов <code class="docutils literal notranslate"><span class="pre">reverse()</span></code> для него не имеет реального эффекта (сортировка не определена до вызова <code class="docutils literal notranslate"><span class="pre">reverse()</span></code> и останется неопределенной после этого).</p>
</div>
<div class="section" id="s-distinct">
<span id="distinct"></span><h4><code class="docutils literal notranslate"><span class="pre">distinct()</span></code><a class="headerlink" href="#distinct" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.distinct">
<code class="descname">distinct</code>(<em><span class="o">*</span><span class="n">fields</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.distinct" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает новый <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, который использует <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">DISTINCT</span></code> в своем SQL-запросе. Это исключает повторяющиеся строки из результатов запроса.</p>
<p>По умолчанию <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> не удаляет повторяющиеся строки. На практике это редко является проблемой, потому что простые запросы, такие как <code class="docutils literal notranslate"><span class="pre">Blog.objects.all()</span></code>, не вводят возможность дублирования строк результатов. Однако, если ваш запрос охватывает несколько таблиц, можно получить дублированные результаты при вычислении <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>. В этом случае вы будете использовать <code class="docutils literal notranslate"><span class="pre">distinct()</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p>Любые поля, используемые в вызове <a class="reference internal" href="#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_by()</span></code></a>, включены в столбцы SQL <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>. Иногда это может привести к неожиданным результатам при использовании в сочетании с <code class="docutils literal notranslate"><span class="pre">distinct()</span></code>. Если вы упорядочиваете по полям из связанной модели, эти поля будут добавлены в выбранные столбцы, и в противном случае дублирующие строки могут оказаться разными. Поскольку дополнительные столбцы не отображаются в возвращаемых результатах (они предназначены только для поддержки сортировки), иногда кажется, что возвращаются нечеткие результаты.</p>
<p>Аналогично, если вы используете запрос <a class="reference internal" href="#django.db.models.query.QuerySet.values" title="django.db.models.query.QuerySet.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code></a> для ограничения выбранных столбцов, столбцы, используемые в любом из <a class="reference internal" href="#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_by()</span></code></a> (или сортировка мо      дели по умолчанию), все равно будут задействованы и могут повлиять на уникальность результатов.</p>
<p class="last">Мораль здесь заключается в том, что если вы используете <code class="docutils literal notranslate"><span class="pre">distinct()</span></code>, будьте осторожны с сортировкой по связанным моделям. Аналогично, при совместном использовании <code class="docutils literal notranslate"><span class="pre">distinct()</span></code> и <a class="reference internal" href="#django.db.models.query.QuerySet.values" title="django.db.models.query.QuerySet.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code></a> будьте осторожны при сортировке по полям, не входящим в вызов <a class="reference internal" href="#django.db.models.query.QuerySet.values" title="django.db.models.query.QuerySet.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code></a>.</p>
</div>
<p>Только в PostgreSQL вы можете передавать позиционные аргументы (<code class="docutils literal notranslate"><span class="pre">*fields</span></code>), чтобы указать имена полей, к которым должен применяться <code class="docutils literal notranslate"><span class="pre">DISTINCT</span></code>. Это преобразуется в SQL-запрос <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">DISTINCT</span> <span class="pre">ON</span></code>. Вот в чем разница. Для обычного вызова <code class="docutils literal notranslate"><span class="pre">distinct()</span></code> база данных сравнивает <em>каждое</em> поле в каждой строке, определяя, какие строки различны. Для вызова <code class="docutils literal notranslate"><span class="pre">distinct()</span></code> с указанными именами полей, база данных будет сравнивать только указанные имена полей.</p>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p>Когда вы указываете имена полей, вы <em>должны</em> использовать <code class="docutils literal notranslate"><span class="pre">order_by()</span></code> в <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, а поля в <code class="docutils literal notranslate"><span class="pre">order_by()</span></code> должны начинаться с полей в <code class="docutils literal notranslate"><span class="pre">distinct()</span></code>, в том же порядке.</p>
<p class="last">Например, <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">DISTINCT</span> <span class="pre">ON</span> <span class="pre">(a)</span></code> дает вам первую строку для каждого значения в столбце <code class="docutils literal notranslate"><span class="pre">a</span></code>. Если вы не укажете сортировку, вы получите произвольную строку.</p>
</div>
<p>Примеры (те, которые после первого будут работать только на PostgreSQL):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span>
<span class="go">[...]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">distinct</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">)</span>
<span class="go">[...]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;blog&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">distinct</span><span class="p">(</span><span class="s">&#39;blog&#39;</span><span class="p">)</span>
<span class="go">[...]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;author&#39;</span><span class="p">,</span> <span class="s">&#39;pub_date&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">distinct</span><span class="p">(</span><span class="s">&#39;author&#39;</span><span class="p">,</span> <span class="s">&#39;pub_date&#39;</span><span class="p">)</span>
<span class="go">[...]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;blog__name&#39;</span><span class="p">,</span> <span class="s">&#39;mod_date&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">distinct</span><span class="p">(</span><span class="s">&#39;blog__name&#39;</span><span class="p">,</span> <span class="s">&#39;mod_date&#39;</span><span class="p">)</span>
<span class="go">[...]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;author&#39;</span><span class="p">,</span> <span class="s">&#39;pub_date&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">distinct</span><span class="p">(</span><span class="s">&#39;author&#39;</span><span class="p">)</span>
<span class="go">[...]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p>Имейте в виду, что <a class="reference internal" href="#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_by()</span></code></a> использует любую сортировку по умолчанию, связанную с моделью, которая была определена. Возможно, вам придется явно сортировать по отношению <code class="docutils literal notranslate"><span class="pre">_id</span></code> или по указанному полю, чтобы убедиться, что выражения <code class="docutils literal notranslate"><span class="pre">DISTINCT</span> <span class="pre">ON</span></code> совпадают с выражениями в начале <code class="docutils literal notranslate"><span class="pre">ORDER</span> <span class="pre">BY</span></code>. Например, если модель <code class="docutils literal notranslate"><span class="pre">Blog</span></code> определила <a class="reference internal" href="../options/#django.db.models.Options.ordering" title="django.db.models.Options.ordering"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ordering</span></code></a> с помощью <code class="docutils literal notranslate"><span class="pre">name</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;blog&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">distinct</span><span class="p">(</span><span class="s">&#39;blog&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">… не сработает, потому что запрос будет отсортирован по <code class="docutils literal notranslate"><span class="pre">blog__name</span></code>, что не соответствует выражению <code class="docutils literal notranslate"><span class="pre">DISTINCT</span> <span class="pre">ON</span></code>. Вам нужно явно упорядочить по полю отношения <code class="docutils literal notranslate"><span class="pre">_id</span></code> (в данном случае <code class="docutils literal notranslate"><span class="pre">blog_id</span></code>) или по ссылке (<code class="docutils literal notranslate"><span class="pre">blog__pk</span></code>), чтобы убедиться, что оба выражения совпадают.</p>
</div>
</div>
<div class="section" id="s-values">
<span id="values"></span><h4><code class="docutils literal notranslate"><span class="pre">values()</span></code><a class="headerlink" href="#values" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.values">
<code class="descname">values</code>(<em><span class="o">*</span><span class="n">fields</span></em>, <em><span class="o">**</span><span class="n">expressions</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.values" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, который возвращает словари, а не экземпляры модели, когда используется как итеративный.</p>
<p>Каждый из этих словарей представляет объект с ключами, соответствующими именам атрибутов объектов модели.</p>
<p>В этом примере сравниваются словари <code class="docutils literal notranslate"><span class="pre">values()</span></code> с объектами нормальной модели:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="c"># This list contains a Blog object.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__startswith</span><span class="o">=</span><span class="s">&#39;Beatles&#39;</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">Blog</span><span class="p">:</span> <span class="n">Beatles</span> <span class="n">Blog</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span>

<span class="c"># This list contains a dictionary.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__startswith</span><span class="o">=</span><span class="s">&#39;Beatles&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
<span class="o">&lt;</span><span class="n">QuerySet</span> <span class="p">[{</span><span class="s">&#39;id&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;Beatles Blog&#39;</span><span class="p">,</span> <span class="s">&#39;tagline&#39;</span><span class="p">:</span> <span class="s">&#39;All the latest Beatles news.&#39;</span><span class="p">}]</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Метод <code class="docutils literal notranslate"><span class="pre">values()</span></code> принимает необязательные позиционные аргументы, <code class="docutils literal notranslate"><span class="pre">*fields</span></code>, которые определяют имена полей, которыми должен ограничиваться <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>. Если вы укажете поля, каждый словарь будет содержать только ключи/значения полей для указанных вами полей. Если вы не укажете поля, каждый словарь будет содержать ключ и значение для каждого поля в таблице базы данных.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
<span class="go">&lt;QuerySet [{&#39;id&#39;: 1, &#39;name&#39;: &#39;Beatles Blog&#39;, &#39;tagline&#39;: &#39;All the latest Beatles news.&#39;}]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [{&#39;id&#39;: 1, &#39;name&#39;: &#39;Beatles Blog&#39;}]&gt;</span>
</pre></div>
</div>
<p>Метод <code class="docutils literal notranslate"><span class="pre">values()</span></code> также принимает необязательные именованные аргументы, <code class="docutils literal notranslate"><span class="pre">**expressions</span></code>, которые передаются через <a class="reference internal" href="#django.db.models.query.QuerySet.annotate" title="django.db.models.query.QuerySet.annotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">annotate()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models.functions</span> <span class="k">import</span> <span class="n">Lower</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">lower_name</span><span class="o">=</span><span class="n">Lower</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">))</span>
<span class="go">&lt;QuerySet [{&#39;lower_name&#39;: &#39;beatles blog&#39;}]&gt;</span>
</pre></div>
</div>
<p>Вы можете использовать встроенные и <a class="reference internal" href="../../../howto/custom-lookups/"><span class="doc">собственные средства поиска</span></a> при сортировке. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="k">import</span> <span class="n">CharField</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models.functions</span> <span class="k">import</span> <span class="n">Lower</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CharField</span><span class="o">.</span><span class="n">register_lookup</span><span class="p">(</span><span class="n">Lower</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;name__lower&#39;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [{&#39;name__lower&#39;: &#39;beatles blog&#39;}]&gt;</span>
</pre></div>
</div>
<p>Аггрегирование с <code class="docutils literal notranslate"><span class="pre">values()</span></code> применяется перед другими аргументами в том же выражении <code class="docutils literal notranslate"><span class="pre">values()</span></code>. Если вам нужно сгруппировать по другому значению, добавьте его в более раннее выражение <code class="docutils literal notranslate"><span class="pre">values()</span></code>. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="k">import</span> <span class="n">Count</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;entry__authors&#39;</span><span class="p">,</span> <span class="n">entries</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">))</span>
<span class="go">&lt;QuerySet [{&#39;entry__authors&#39;: 1, &#39;entries&#39;: 20}, {&#39;entry__authors&#39;: 1, &#39;entries&#39;: 13}]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;entry__authors&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">entries</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">))</span>
<span class="go">&lt;QuerySet [{&#39;entry__authors&#39;: 1, &#39;entries&#39;: 33}]&gt;</span>
</pre></div>
</div>
<p>Несколько тонкостей, о которых стоит упомянуть:</p>
<ul>
<li><p class="first">Если у вас есть поле с именем <code class="docutils literal notranslate"><span class="pre">foo</span></code>, которое является <a class="reference internal" href="../fields/#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>, вызов <code class="docutils literal notranslate"><span class="pre">values()</span></code> по умолчанию вернет ключ словаря с именем <code class="docutils literal notranslate"><span class="pre">foo_id</span></code>, поскольку это имя атрибута скрытой модели, в котором хранится фактическое значение (атрибут <code class="docutils literal notranslate"><span class="pre">foo</span></code> относится к связанной модели). Когда вы вызываете <code class="docutils literal notranslate"><span class="pre">values()</span></code> и передаете имена полей, вы можете передать либо <code class="docutils literal notranslate"><span class="pre">foo</span></code>, либо <code class="docutils literal notranslate"><span class="pre">foo_id</span></code>, и вы получите то же самое (ключ словаря будет соответствовать имени поля, которые вы передали).</p>
<p>Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
<span class="go">&lt;QuerySet [{&#39;blog_id&#39;: 1, &#39;headline&#39;: &#39;First Entry&#39;, ...}, ...]&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;blog&#39;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [{&#39;blog&#39;: 1}, ...]&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;blog_id&#39;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [{&#39;blog_id&#39;: 1}, ...]&gt;</span>
</pre></div>
</div>
</li>
<li><p class="first">При использовании <code class="docutils literal notranslate"><span class="pre">values()</span></code> вместе с <a class="reference internal" href="#django.db.models.query.QuerySet.distinct" title="django.db.models.query.QuerySet.distinct"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distinct()</span></code></a> помните, что сортировка может повлиять на результаты. Смотрите примечание в <a class="reference internal" href="#django.db.models.query.QuerySet.distinct" title="django.db.models.query.QuerySet.distinct"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distinct()</span></code></a> для деталей.</p>
</li>
<li><p class="first">Если вы используете выражение <code class="docutils literal notranslate"><span class="pre">values()</span></code> после вызова <a class="reference internal" href="#django.db.models.query.QuerySet.extra" title="django.db.models.query.QuerySet.extra"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extra()</span></code></a>, любые поля, определенные аргументом <code class="docutils literal notranslate"><span class="pre">select</span></code> в <a class="reference internal" href="#django.db.models.query.QuerySet.extra" title="django.db.models.query.QuerySet.extra"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extra()</span></code></a>, должны быть явно включены в вызов <code class="docutils literal notranslate"><span class="pre">values()</span></code>. При любом вызов <a class="reference internal" href="#django.db.models.query.QuerySet.extra" title="django.db.models.query.QuerySet.extra"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extra()</span></code></a> после вызова <code class="docutils literal notranslate"><span class="pre">values()</span></code> лишние выбранные поля будут игнорироваться.</p>
</li>
<li><p class="first">Вызов <a class="reference internal" href="#django.db.models.query.QuerySet.only" title="django.db.models.query.QuerySet.only"><code class="xref py py-meth docutils literal notranslate"><span class="pre">only()</span></code></a> и <a class="reference internal" href="#django.db.models.query.QuerySet.defer" title="django.db.models.query.QuerySet.defer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">defer()</span></code></a> после values() не имеет смысла, поэтому это вызовет ошибку <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>.</p>
</li>
<li><p class="first">Объединение преобразований и агрегирования требует использования двух вызовов <a class="reference internal" href="#django.db.models.query.QuerySet.annotate" title="django.db.models.query.QuerySet.annotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">annotate()</span></code></a>, либо явно, либо в качестве именованных аргументов для <a class="reference internal" href="#django.db.models.query.QuerySet.values" title="django.db.models.query.QuerySet.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code></a>. Как и выше, если преобразование зарегистрировано в соответствующем типе поля, первое <a class="reference internal" href="#django.db.models.query.QuerySet.annotate" title="django.db.models.query.QuerySet.annotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">annotate()</span></code></a> может быть опущено, поэтому следующие примеры эквивалентны:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="k">import</span> <span class="n">CharField</span><span class="p">,</span> <span class="n">Count</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models.functions</span> <span class="k">import</span> <span class="n">Lower</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CharField</span><span class="o">.</span><span class="n">register_lookup</span><span class="p">(</span><span class="n">Lower</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;entry__authors__name__lower&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">entries</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">))</span>
<span class="go">&lt;QuerySet [{&#39;entry__authors__name__lower&#39;: &#39;test author&#39;, &#39;entries&#39;: 33}]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">entry__authors__name__lower</span><span class="o">=</span><span class="n">Lower</span><span class="p">(</span><span class="s">&#39;entry__authors__name&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">entries</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">))</span>
<span class="go">&lt;QuerySet [{&#39;entry__authors__name__lower&#39;: &#39;test author&#39;, &#39;entries&#39;: 33}]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">entry__authors__name__lower</span><span class="o">=</span><span class="n">Lower</span><span class="p">(</span><span class="s">&#39;entry__authors__name&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;entry__authors__name__lower&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">entries</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">))</span>
<span class="go">&lt;QuerySet [{&#39;entry__authors__name__lower&#39;: &#39;test author&#39;, &#39;entries&#39;: 33}]&gt;</span>
</pre></div>
</div>
</li>
</ul>
<p>Это полезно, когда вы знаете, что вам понадобятся значения только из небольшого числа доступных полей, и вам не понадобятся функциональные возможности объекта экземпляра модели. Более эффективно выбирать только те поля, которые вам нужны.</p>
<p>Наконец, обратите внимание, что вы можете вызывать <code class="docutils literal notranslate"><span class="pre">filter()</span></code>, <code class="docutils literal notranslate"><span class="pre">order_by()</span></code> и т.д. после вызова <code class="docutils literal notranslate"><span class="pre">values()</span></code>, это означает, что эти два вызова идентичны:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">()</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)</span>
<span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
</pre></div>
</div>
<p>Люди, которые сделали Django, предпочитают сначала поместить все методы, влияющие на SQL, а затем (необязательно) любые методы, влияющие на вывод (такие как <code class="docutils literal notranslate"><span class="pre">values()</span></code>), но это не имеет большого значения. Это ваш шанс по-настоящему выставить напоказ свой индивидуализм.</p>
<p>Вы также можете ссылаться на поля в связанных моделях с обратными связями через атрибуты <code class="docutils literal notranslate"><span class="pre">OneToOneField</span></code>, <code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> и <code class="docutils literal notranslate"><span class="pre">ManyToManyField</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;entry__headline&#39;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [{&#39;name&#39;: &#39;My blog&#39;, &#39;entry__headline&#39;: &#39;An entry&#39;},</span>
<span class="go">     {&#39;name&#39;: &#39;My blog&#39;, &#39;entry__headline&#39;: &#39;Another entry&#39;}, ...]&gt;</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p class="last">Потому что <a class="reference internal" href="../fields/#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> атрибуты и обратные отношения могут иметь несколько связанных строк, в том числе они могут повлиять на размер набора результатов. Это будет особенно заметно, если вы включите несколько таких полей в ваш запрос <code class="docutils literal notranslate"><span class="pre">values()</span></code>, и в этом случае будут возвращены все возможные комбинации.</p>
</div>
<div class="admonition-boolean-values-for-jsonfield-on-sqlite admonition">
<p class="first admonition-title">Логические значения для <code class="docutils literal notranslate"><span class="pre">JSONField</span></code> в SQLite</p>
<p class="last">Из-за того, как SQL-функция <code class="docutils literal notranslate"><span class="pre">JSON_EXTRACT</span></code> реализована в SQLite, <code class="docutils literal notranslate"><span class="pre">values()</span></code> вернет <code class="docutils literal notranslate"><span class="pre">1</span></code> и <code class="docutils literal notranslate"><span class="pre">0</span></code> вместо <code class="docutils literal notranslate"><span class="pre">True</span></code> и <code class="docutils literal notranslate"><span class="pre">False</span></code> для преобразования ключа <a class="reference internal" href="../fields/#django.db.models.JSONField" title="django.db.models.JSONField"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSONField</span></code></a>.</p>
</div>
</div>
<div class="df-ads">
    <!-- Yandex.RTB R-A-395615-8 -->
    <div id="yandex_rtb_R-A-395615-8"></div>
    <script type="text/javascript">
        (function(w, d, n, s, t) {
            w[n] = w[n] || [];
            w[n].push(function() {
                Ya.Context.AdvManager.render({
                    blockId: "R-A-395615-8",
                    renderTo: "yandex_rtb_R-A-395615-8",
                    async: true
                });
            });
            t = d.getElementsByTagName("script")[0];
            s = d.createElement("script");
            s.type = "text/javascript";
            s.src = "//an.yandex.ru/system/context.js";
            s.async = true;
            t.parentNode.insertBefore(s, t);
        })(this, this.document, "yandexContextAsyncCallbacks");
    </script>
    </div><div class="section" id="s-values-list">
<span id="values-list"></span><h4><code class="docutils literal notranslate"><span class="pre">values_list()</span></code><a class="headerlink" href="#values-list" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.values_list">
<code class="descname">values_list</code>(<em><span class="o">*</span><span class="n">fields</span></em>, <em><span class="n">flat</span><span class="o">=</span><span class="default_value">False</span></em>, <em><span class="n">named</span><span class="o">=</span><span class="default_value">False</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.values_list" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Это похоже на <code class="docutils literal notranslate"><span class="pre">values()</span></code>, за исключением того, что вместо возврата словарей он возвращает кортежи при повторении. Каждый кортеж содержит значение из соответствующего поля или выражения, переданное в вызов <code class="docutils literal notranslate"><span class="pre">values_list()</span></code> - поэтому первый элемент является первым полем и т.д. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="s">&#39;headline&#39;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [(1, &#39;First entry&#39;), ...]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models.functions</span> <span class="k">import</span> <span class="n">Lower</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="n">Lower</span><span class="p">(</span><span class="s">&#39;headline&#39;</span><span class="p">))</span>
<span class="go">&lt;QuerySet [(1, &#39;first entry&#39;), ...]&gt;</span>
</pre></div>
</div>
<p>Если вы передаете только одно поле, вы также можете передать параметр <code class="docutils literal notranslate"><span class="pre">flat</span></code>. Если <code class="docutils literal notranslate"><span class="pre">True</span></code>, это будет означать, что возвращаемые результаты будут единичными значениями, а не кортежем. Пример должен прояснить разницу:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)</span>
<span class="go">&lt;QuerySet[(1,), (2,), (3,), ...]&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="k">True</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [1, 2, 3, ...]&gt;</span>
</pre></div>
</div>
<p>Ошибочно передавать в <code class="docutils literal notranslate"><span class="pre">flat</span></code>, когда имеется более одного поля.</p>
<p>Вы можете передать <code class="docutils literal notranslate"><span class="pre">named=True</span></code> для получения результатов в виде <code class="xref py py-func docutils literal notranslate"><span class="pre">collection.namedtuple</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="s">&#39;headline&#39;</span><span class="p">,</span> <span class="n">named</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
<span class="go">&lt;QuerySet [Row(id=1, headline=&#39;First entry&#39;), ...]&gt;</span>
</pre></div>
</div>
<p>Использование именованного кортежа может сделать результаты более читабельными за счет небольшого снижения производительности за преобразование результатов в именованный кортеж.</p>
<p>Если вы не передадите никаких значений в <code class="docutils literal notranslate"><span class="pre">values_list()</span></code>, он вернет все поля в модели в том порядке, в котором они были объявлены.</p>
<p>Общей необходимостью является получение определенного значения поля определенного экземпляра модели. Для этого используйте <code class="docutils literal notranslate"><span class="pre">values_list()</span></code>, а затем <code class="docutils literal notranslate"><span class="pre">get()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">&#39;headline&#39;</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="k">True</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;First entry&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">values()</span></code> и <code class="docutils literal notranslate"><span class="pre">values_list()</span></code> предназначены для оптимизации для конкретного случая использования: извлечение подмножества данных без затрат на создание экземпляра модели. Эта метафора разваливается при работе со многими ко многим и другими многозначными отношениями (такими как отношение «один ко многим» обратного внешнего ключа), потому что предположение «одна строка, один объект» не выполняется.</p>
<p>Например, обратите внимание на поведение при запросе через <a class="reference internal" href="../fields/#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;entry__headline&#39;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [(&#39;Noam Chomsky&#39;, &#39;Impressions of Gaza&#39;),</span>
<span class="go"> (&#39;George Orwell&#39;, &#39;Why Socialists Do Not Believe in Fun&#39;),</span>
<span class="go"> (&#39;George Orwell&#39;, &#39;In Defence of English Cooking&#39;),</span>
<span class="go"> (&#39;Don Quixote&#39;, None)]&gt;</span>
</pre></div>
</div>
<p>Авторы с несколькими записями появляются несколько раз, а авторы без записей имеют <code class="docutils literal notranslate"><span class="pre">None</span></code> для заголовка записи.</p>
<p>Аналогично, при запросе обратного внешнего ключа, <code class="docutils literal notranslate"><span class="pre">None</span></code> появляется для записей, не имеющих автора:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">&#39;authors&#39;</span><span class="p">)</span>
<span class="go">&lt;QuerySet [(&#39;Noam Chomsky&#39;,), (&#39;George Orwell&#39;,), (None,)]&gt;</span>
</pre></div>
</div>
<div class="admonition-boolean-values-for-jsonfield-on-sqlite admonition">
<p class="first admonition-title">Логические значения для <code class="docutils literal notranslate"><span class="pre">JSONField</span></code> в SQLite</p>
<p class="last">Из-за того, как SQL-функция <code class="docutils literal notranslate"><span class="pre">JSON_EXTRACT</span></code> реализована в SQLite, <code class="docutils literal notranslate"><span class="pre">values_list()</span></code> будет возвращать <code class="docutils literal notranslate"><span class="pre">1</span></code> и <code class="docutils literal notranslate"><span class="pre">0</span></code> вместо <code class="docutils literal notranslate"><span class="pre">True</span></code> и <code class="docutils literal notranslate"><span class="pre">False</span></code> для преобразования ключа <a class="reference internal" href="../fields/#django.db.models.JSONField" title="django.db.models.JSONField"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSONField</span></code></a>.</p>
</div>
</div>
<div class="section" id="s-dates">
<span id="dates"></span><h4><code class="docutils literal notranslate"><span class="pre">dates()</span></code><a class="headerlink" href="#dates" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.dates">
<code class="descname">dates</code>(<em><span class="n">field</span></em>, <em><span class="n">kind</span></em>, <em><span class="n">order</span><span class="o">=</span><span class="default_value">'ASC'</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.dates" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, который вычисляет список объектов <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.date" title="(в Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.date</span></code></a>, представляющих все доступные даты определенного вида в <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">field</span></code> должно быть именем <code class="docutils literal notranslate"><span class="pre">DateField</span></code> вашей модели. <code class="docutils literal notranslate"><span class="pre">kind</span></code> должен быть либо <code class="docutils literal notranslate"><span class="pre">&quot;year&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;month&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;week&quot;</span></code>, либо <code class="docutils literal notranslate"><span class="pre">&quot;day&quot;</span></code>. Каждый объект <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.date" title="(в Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.date</span></code></a> в списке результатов «усекается» до заданного <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&quot;year&quot;</span></code> возвращает список всех различных значений года.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;month&quot;</span></code> возвращает список всех различных значений года/месяца.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;week&quot;</span></code> возвращает список всех различных значений года/недели. Все даты будут понедельником.</li>
<li><code class="docutils literal notranslate"><span class="pre">&quot;day&quot;</span></code> возвращает список всех различных значений года/месяца/дня.</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">order</span></code>, который по умолчанию равен <code class="docutils literal notranslate"><span class="pre">'ASC'</span></code>, должен быть либо <code class="docutils literal notranslate"><span class="pre">'ASC'</span></code>, либо <code class="docutils literal notranslate"><span class="pre">'DESC'</span></code>. Это указывает, как сортировать результаты.</p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">dates</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">,</span> <span class="s">&#39;year&#39;</span><span class="p">)</span>
<span class="go">[datetime.date(2005, 1, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">dates</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">,</span> <span class="s">&#39;month&#39;</span><span class="p">)</span>
<span class="go">[datetime.date(2005, 2, 1), datetime.date(2005, 3, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">dates</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">,</span> <span class="s">&#39;week&#39;</span><span class="p">)</span>
<span class="go">[datetime.date(2005, 2, 14), datetime.date(2005, 3, 14)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">dates</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">,</span> <span class="s">&#39;day&#39;</span><span class="p">)</span>
<span class="go">[datetime.date(2005, 2, 20), datetime.date(2005, 3, 20)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">dates</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">,</span> <span class="s">&#39;day&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;DESC&#39;</span><span class="p">)</span>
<span class="go">[datetime.date(2005, 3, 20), datetime.date(2005, 2, 20)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">dates</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">,</span> <span class="s">&#39;day&#39;</span><span class="p">)</span>
<span class="go">[datetime.date(2005, 3, 20)]</span>
</pre></div>
</div>
</div>
<div class="section" id="s-datetimes">
<div class="df-ads">
    <!-- Yandex.RTB R-A-395615-9 -->
    <div id="yandex_rtb_R-A-395615-9"></div>
    <script type="text/javascript">
        (function(w, d, n, s, t) {
            w[n] = w[n] || [];
            w[n].push(function() {
                Ya.Context.AdvManager.render({
                    blockId: "R-A-395615-9",
                    renderTo: "yandex_rtb_R-A-395615-9",
                    async: true
                });
            });
            t = d.getElementsByTagName("script")[0];
            s = d.createElement("script");
            s.type = "text/javascript";
            s.src = "//an.yandex.ru/system/context.js";
            s.async = true;
            t.parentNode.insertBefore(s, t);
        })(this, this.document, "yandexContextAsyncCallbacks");
    </script>
    </div><span id="datetimes"></span><h4><code class="docutils literal notranslate"><span class="pre">datetimes()</span></code><a class="headerlink" href="#datetimes" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.datetimes">
<code class="descname">datetimes</code>(<em><span class="n">field_name</span></em>, <em><span class="n">kind</span></em>, <em><span class="n">order</span><span class="o">=</span><span class="default_value">'ASC'</span></em>, <em><span class="n">tzinfo</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">is_dst</span><span class="o">=</span><span class="default_value">None</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.datetimes" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, который оценивает список объектов <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(в Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a>, представляющих все доступные даты определенного вида в содержимом <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">field_name`</span> <span class="pre">должно</span> <span class="pre">быть</span> <span class="pre">именем</span> <span class="pre">``DateTimeField</span></code> вашей модели.</p>
<p><code class="docutils literal notranslate"><span class="pre">kind</span></code> должен быть одним из: <code class="docutils literal notranslate"><span class="pre">&quot;year&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;month&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;week&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;day&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;hour&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;minute&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;second&quot;</span></code>. Каждый объект <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(в Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.datetime</span></code></a> в списке результатов «усекается» до заданного <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">order</span></code>, который по умолчанию равен <code class="docutils literal notranslate"><span class="pre">'ASC'</span></code>, должен быть либо <code class="docutils literal notranslate"><span class="pre">'ASC'</span></code>, либо <code class="docutils literal notranslate"><span class="pre">'DESC'</span></code>. Это указывает, как сортировать результаты.</p>
<p><code class="docutils literal notranslate"><span class="pre">tzinfo</span></code> определяет часовой пояс, в который конвертируются даты и время перед усечением. Действительно, данная дата и время имеют разные представления в зависимости от используемого часового пояса. Этот параметр должен быть объектом <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.tzinfo" title="(в Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.tzinfo</span></code></a>. Если это <code class="docutils literal notranslate"><span class="pre">None</span></code>, Django использует <a class="reference internal" href="../../../topics/i18n/timezones/#default-current-time-zone"><span class="std std-ref">текущий часовой пояс</span></a>. Это не действует, если <a class="reference internal" href="../../settings/#std-setting-USE_TZ"><code class="xref std std-setting docutils literal notranslate"><span class="pre">USE_TZ</span></code></a> равно <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">is_dst</span></code> указывает, должен ли <code class="docutils literal notranslate"><span class="pre">pytz</span></code> интерпретировать несуществующие и неоднозначные даты в летнее время. По умолчанию (когда <code class="docutils literal notranslate"><span class="pre">is_dst=None</span></code>), <code class="docutils literal notranslate"><span class="pre">pytz</span></code> выдает исключение для таких datetime.</p>
<div class="versionadded">
<span class="title">New in Django 3.1:</span> <p>Был добавлен параметр <code class="docutils literal notranslate"><span class="pre">is_dst</span></code>.</p>
</div>
<div class="admonition note" id="database-time-zone-definitions">
<p class="first admonition-title">Примечание</p>
<p>Эта функция выполняет преобразование часового пояса непосредственно в базе данных. Как следствие, ваша база данных должна иметь возможность интерпретировать значение <code class="docutils literal notranslate"><span class="pre">tzinfo.tzname(None)</span></code>. Это приводит к следующим требованиям:</p>
<ul class="last simple">
<li>SQLite: нет требований. Преобразования выполняются в Python с помощью <a class="reference external" href="http://pytz.sourceforge.net/">pytz</a> (устанавливается при установке Django).</li>
<li>PostgreSQL: никаких требований (см. <a class="reference external" href="https://www.postgresql.org/docs/current/datatype-datetime.html#DATATYPE-TIMEZONES">Часовые пояса</a>).</li>
<li>Oracle: нет требований (см. <a class="reference external" href="https://docs.oracle.com/en/database/oracle/">Выбор файла часового пояса</a>).</li>
<li>MySQL: загрузить таблицы часовых поясов с помощью <a class="reference external" href="https://dev.mysql.com/doc/refman/en/mysql-tzinfo-to-sql.html">mysql_tzinfo_to_sql</a>.</li>
</ul>
</div>
</div>
<div class="section" id="s-none">
<span id="none"></span><h4><code class="docutils literal notranslate"><span class="pre">none()</span></code><a class="headerlink" href="#none" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.none">
<code class="descname">none</code>()<a class="headerlink" href="#django.db.models.query.QuerySet.none" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Вызов <code class="docutils literal notranslate"><span class="pre">none()</span></code> создаст набор запросов, который никогда не возвращает никаких объектов, и никакой запрос не будет выполняться при доступе к результатам. Набор запросов <code class="docutils literal notranslate"><span class="pre">qs.none()</span></code> является экземпляром <code class="docutils literal notranslate"><span class="pre">EmptyQuerySet</span></code>.</p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">none</span><span class="p">()</span>
<span class="go">&lt;QuerySet []&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models.query</span> <span class="k">import</span> <span class="n">EmptyQuerySet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">none</span><span class="p">(),</span> <span class="n">EmptyQuerySet</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="s-all">
<span id="all"></span><h4><code class="docutils literal notranslate"><span class="pre">all()</span></code><a class="headerlink" href="#all" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.all">
<code class="descname">all</code>()<a class="headerlink" href="#django.db.models.query.QuerySet.all" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает <em>копию</em> текущего <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> (или подкласса <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>). Это может быть полезно в ситуациях, когда вы захотите передать либо менеджер модели, либо <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> и выполнить дальнейшую фильтрацию по результату. После вызова <code class="docutils literal notranslate"><span class="pre">all()</span></code> для любого объекта у вас обязательно будет <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> для работы.</p>
<p>Когда <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> <a class="reference internal" href="#when-querysets-are-evaluated"><span class="std std-ref">вычисляется</span></a>, он обычно кэширует свои результаты. Если данные в базе данных могли измениться после вычисления <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, вы можете получить обновленные результаты для того же запроса, вызвав <code class="docutils literal notranslate"><span class="pre">all()</span></code> для ранее вычисленного <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>.</p>
</div>
<div class="df-ads">
    <!-- Yandex.RTB R-A-395615-10 -->
    <div id="yandex_rtb_R-A-395615-10"></div>
    <script type="text/javascript">
        (function(w, d, n, s, t) {
            w[n] = w[n] || [];
            w[n].push(function() {
                Ya.Context.AdvManager.render({
                    blockId: "R-A-395615-10",
                    renderTo: "yandex_rtb_R-A-395615-10",
                    async: true
                });
            });
            t = d.getElementsByTagName("script")[0];
            s = d.createElement("script");
            s.type = "text/javascript";
            s.src = "//an.yandex.ru/system/context.js";
            s.async = true;
            t.parentNode.insertBefore(s, t);
        })(this, this.document, "yandexContextAsyncCallbacks");
    </script>
    </div><div class="section" id="s-union">
<span id="union"></span><h4><code class="docutils literal notranslate"><span class="pre">union()</span></code><a class="headerlink" href="#union" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.union">
<code class="descname">union</code>(<em><span class="o">*</span><span class="n">other_qs</span></em>, <em><span class="n">all</span><span class="o">=</span><span class="default_value">False</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.union" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Использует оператор SQL <code class="docutils literal notranslate"><span class="pre">UNION</span></code> для объединения результатов двух или более <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>’ов. Например:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qs1</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">qs2</span><span class="p">,</span> <span class="n">qs3</span><span class="p">)</span>
</pre></div>
</div>
<p>Оператор <code class="docutils literal notranslate"><span class="pre">UNION</span></code> выбирает только отдельные значения по умолчанию. Чтобы разрешить повторяющиеся значения, используйте аргумент <code class="docutils literal notranslate"><span class="pre">all=True</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">union()</span></code>, <code class="docutils literal notranslate"><span class="pre">intersection()</span></code> и <code class="docutils literal notranslate"><span class="pre">difference()</span></code> возвращают экземпляры модели с типом первого <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, даже если аргументами являются <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> других моделей. Передача разных моделей работает до тех пор, пока список <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> одинаков во всех <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> (по крайней мере, типы, имена не имеют значения, если типы находятся в одном порядке). В таких случаях вы должны использовать имена столбцов из первого <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> в методах <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, примененных к результирующему <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qs1</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qs2</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">&#39;headline&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qs1</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">qs2</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Кроме того, только <code class="docutils literal notranslate"><span class="pre">LIMIT</span></code>, <code class="docutils literal notranslate"><span class="pre">OFFSET</span></code>, <code class="docutils literal notranslate"><span class="pre">COUNT(*)</span></code>, <code class="docutils literal notranslate"><span class="pre">ORDER</span> <span class="pre">BY</span></code> и указание столбцов (т.е. срезов, <a class="reference internal" href="#django.db.models.query.QuerySet.count" title="django.db.models.query.QuerySet.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code></a>, <a class="reference internal" href="#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_by()</span></code></a> и <code class="xref py py-meth docutils literal notranslate"><span class="pre">values</span> <span class="pre">()</span></code>/<a class="reference internal" href="#django.db.models.query.QuerySet.values_list" title="django.db.models.query.QuerySet.values_list"><code class="xref py py-meth docutils literal notranslate"><span class="pre">values_list()</span></code></a>) разрешены в результирующем <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>. Кроме того, базы данных накладывают ограничения на то, какие операции разрешены в комбинированных запросах. Например, большинство баз данных не допускают <code class="docutils literal notranslate"><span class="pre">LIMIT</span></code> или <code class="docutils literal notranslate"><span class="pre">OFFSET</span></code> в комбинированных запросах.</p>
</div>
<div class="section" id="s-intersection">
<span id="intersection"></span><h4><code class="docutils literal notranslate"><span class="pre">intersection()</span></code><a class="headerlink" href="#intersection" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.intersection">
<code class="descname">intersection</code>(<em><span class="o">*</span><span class="n">other_qs</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.intersection" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Использует оператор SQL <code class="docutils literal notranslate"><span class="pre">INTERSECT</span></code> для возврата общих элементов двух или более <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>’ов. Например:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qs1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">qs2</span><span class="p">,</span> <span class="n">qs3</span><span class="p">)</span>
</pre></div>
</div>
<p>Смотрите <a class="reference internal" href="#django.db.models.query.QuerySet.union" title="django.db.models.query.QuerySet.union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">union()</span></code></a> для некоторых ограничений.</p>
</div>
<div class="section" id="s-difference">
<div class="df-ads">
    <!-- Yandex.RTB R-A-395615-11 -->
    <div id="yandex_rtb_R-A-395615-11"></div>
    <script type="text/javascript">
        (function(w, d, n, s, t) {
            w[n] = w[n] || [];
            w[n].push(function() {
                Ya.Context.AdvManager.render({
                    blockId: "R-A-395615-11",
                    renderTo: "yandex_rtb_R-A-395615-11",
                    async: true
                });
            });
            t = d.getElementsByTagName("script")[0];
            s = d.createElement("script");
            s.type = "text/javascript";
            s.src = "//an.yandex.ru/system/context.js";
            s.async = true;
            t.parentNode.insertBefore(s, t);
        })(this, this.document, "yandexContextAsyncCallbacks");
    </script>
    </div><span id="difference"></span><h4><code class="docutils literal notranslate"><span class="pre">difference()</span></code><a class="headerlink" href="#difference" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.difference">
<code class="descname">difference</code>(<em><span class="o">*</span><span class="n">other_qs</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.difference" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Использует оператор SQL <code class="docutils literal notranslate"><span class="pre">EXCEPT</span></code> для хранения только элементов, присутствующих в <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, но не в каких-либо других <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>’ах. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qs1</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">qs2</span><span class="p">,</span> <span class="n">qs3</span><span class="p">)</span>
</pre></div>
</div>
<p>Смотрите <a class="reference internal" href="#django.db.models.query.QuerySet.union" title="django.db.models.query.QuerySet.union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">union()</span></code></a> для некоторых ограничений.</p>
</div>
<div class="section" id="s-select-related">
<span id="select-related"></span><h4><code class="docutils literal notranslate"><span class="pre">select_related()</span></code><a class="headerlink" href="#select-related" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.select_related">
<code class="descname">select_related</code>(<em><span class="o">*</span><span class="n">fields</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.select_related" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, который будет «следовать» отношениям внешнего ключа, выбирая дополнительные данные связанного объекта при выполнении своего запроса. Это повышение производительности, которое приводит к одному более сложному запросу, но означает, что дальнейшее использование отношений внешнего ключа не потребует запросов к базе данных.</p>
<p>Следующие примеры иллюстрируют разницу между простыми поисками и с использованием <code class="docutils literal notranslate"><span class="pre">select_related()</span></code>. Вот стандартный поиск:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="c"># Hits the database.</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c"># Hits the database again to get the related Blog object.</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">blog</span>
</pre></div>
</div>
<p>И вот с <code class="docutils literal notranslate"><span class="pre">select_related</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="c"># Hits the database.</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">&#39;blog&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c"># Doesn&#39;t hit the database, because e.blog has been prepopulated</span>
<span class="c"># in the previous query.</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">blog</span>
</pre></div>
</div>
<p>Вы можете использовать <code class="docutils literal notranslate"><span class="pre">select_related()</span></code> с любым набором запросов объектов:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.utils</span> <span class="k">import</span> <span class="n">timezone</span>

<span class="c"># Find all the blogs with entries scheduled to be published in the future.</span>
<span class="n">blogs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__gt</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">now</span><span class="p">())</span><span class="o">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">&#39;blog&#39;</span><span class="p">):</span>
    <span class="c"># Without select_related(), this would make a database query for each</span>
    <span class="c"># loop iteration in order to fetch the related blog for each entry.</span>
    <span class="n">blogs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">blog</span><span class="p">)</span>
</pre></div>
</div>
<p>Порядок цепочек <code class="docutils literal notranslate"><span class="pre">filter()</span></code> и <code class="docutils literal notranslate"><span class="pre">select_related()</span></code> не важен. Эти наборы запросов эквивалентны:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__gt</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">now</span><span class="p">())</span><span class="o">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">&#39;blog&#39;</span><span class="p">)</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">&#39;blog&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__gt</span><span class="o">=</span><span class="n">timezone</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
</pre></div>
</div>
<p>Вы можете следить за внешними ключами так же, как запрашивать их. Если у вас есть следующие модели:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.db</span> <span class="k">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">City</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="n">hometown</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span>
        <span class="n">City</span><span class="p">,</span>
        <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">SET_NULL</span><span class="p">,</span>
        <span class="n">blank</span><span class="o">=</span><span class="k">True</span><span class="p">,</span>
        <span class="n">null</span><span class="o">=</span><span class="k">True</span><span class="p">,</span>
    <span class="p">)</span>

<span class="k">class</span> <span class="nc">Book</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="n">author</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Person</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">)</span>
</pre></div>
</div>
<p>…тогда вызов <code class="docutils literal notranslate"><span class="pre">Book.objects.select_related('author__hometown').get(id=4)</span></code> кеширует связанный <code class="docutils literal notranslate"><span class="pre">Person</span></code> <strong>и</strong> связанный <code class="docutils literal notranslate"><span class="pre">City</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="c"># Hits the database with joins to the author and hometown tables.</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">&#39;author__hometown&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">author</span>         <span class="c"># Doesn&#39;t hit the database.</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">hometown</span>       <span class="c"># Doesn&#39;t hit the database.</span>

<span class="c"># Without select_related()...</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  <span class="c"># Hits the database.</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">author</span>         <span class="c"># Hits the database.</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">hometown</span>       <span class="c"># Hits the database.</span>
</pre></div>
</div>
<p>Вы можете ссылаться на любое отношение <a class="reference internal" href="../fields/#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> или <a class="reference internal" href="../fields/#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> в списке полей, передаваемых в <code class="docutils literal notranslate"><span class="pre">select_related()</span></code>.</p>
<p>Вы также можете обратиться к обратному направлению <a class="reference internal" href="../fields/#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> в списке полей, переданных <code class="docutils literal notranslate"><span class="pre">select_related</span></code> - то есть вы можете пройти в <a class="reference internal" href="../fields/#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneToOneField</span></code></a> и вернуться к объекту, для которого определено поле. Вместо указания имени поля используйте <a class="reference internal" href="../fields/#django.db.models.ForeignKey.related_name" title="django.db.models.ForeignKey.related_name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">related_name</span></code></a> для поля в связанном объекте.</p>
<p>Могут быть ситуации, когда вы хотите вызвать <code class="docutils literal notranslate"><span class="pre">select_related()</span></code> с большим количеством связанных объектов, или когда вы не знаете всех отношений. В этих случаях можно вызывать <code class="docutils literal notranslate"><span class="pre">select_related()</span></code> без аргументов. Он будет следовать за всеми ненулевыми внешними ключами, которые он может найти - должны быть указаны внешние ключи, которые могут иметь значение null. Это не рекомендуется в большинстве случаев, так как это может сделать базовый запрос более сложным и вернуть больше данных, чем фактически необходимо.</p>
<p>Если вам нужно очистить список связанных полей, добавленных прошлыми вызовами <code class="docutils literal notranslate"><span class="pre">select_related</span></code> в <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, вы можете передать <code class="docutils literal notranslate"><span class="pre">None</span></code> в качестве параметра:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">without_relations</span> <span class="o">=</span> <span class="n">queryset</span><span class="o">.</span><span class="n">select_related</span><span class="p">(</span><span class="k">None</span><span class="p">)</span>
</pre></div>
</div>
<p>Цепочка вызовов <code class="docutils literal notranslate"><span class="pre">select_related</span></code> работает аналогично другим методам - то есть <code class="docutils literal notranslate"><span class="pre">select_related('foo',</span> <span class="pre">'bar')</span></code> эквивалентна <code class="docutils literal notranslate"><span class="pre">select_related('foo').select_related('bar')</span></code>.</p>
</div>
<div class="section" id="s-prefetch-related">
<span id="prefetch-related"></span><h4><code class="docutils literal notranslate"><span class="pre">prefetch_related()</span></code><a class="headerlink" href="#prefetch-related" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.prefetch_related">
<code class="descname">prefetch_related</code>(<em><span class="o">*</span><span class="n">lookups</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.prefetch_related" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, который автоматически извлекает в одном пакете связанные объекты для каждого из указанных поисков.</p>
<p>Это имеет цель, аналогичную <code class="docutils literal notranslate"><span class="pre">select_related</span></code>, в том смысле, что оба предназначены для остановки потока запросов к базе данных, вызванного доступом к связанным объектам, но стратегия совершенно иная.</p>
<p><code class="docutils literal notranslate"><span class="pre">select_related</span></code> работает путем создания соединения (join) SQL и включения полей связанного объекта в оператор <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>. По этой причине <code class="docutils literal notranslate"><span class="pre">select_related</span></code> получает связанные объекты в одном запросе к базе данных. Тем не менее, чтобы избежать гораздо большего результирующего набора, который мог бы возникнуть в результате объединения через отношение „many“, <code class="docutils literal notranslate"><span class="pre">select_related</span></code> ограничен однозначными отношениями - внешним ключом и один-к-одному.</p>
<p><code class="docutils literal notranslate"><span class="pre">prefetch_related</span></code>, с другой стороны, выполняет отдельный поиск для каждого отношения и выполняет «соединение» в Python. Это позволяет ему предварительно выбирать объекты «многие ко многим» и «многие к одному», что нельзя сделать с помощью <code class="docutils literal notranslate"><span class="pre">select_related</span></code>, в дополнение к внешнему ключу и отношениям «один к одному», которые поддерживаются <code class="docutils literal notranslate"><span class="pre">select_related</span></code>. Он также поддерживает предварительную выборку <a class="reference internal" href="../../contrib/contenttypes/#django.contrib.contenttypes.fields.GenericRelation" title="django.contrib.contenttypes.fields.GenericRelation"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericRelation</span></code></a> и <a class="reference internal" href="../../contrib/contenttypes/#django.contrib.contenttypes.fields.GenericForeignKey" title="django.contrib.contenttypes.fields.GenericForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericForeignKey</span></code></a>, однако он должен быть ограничен однородным набором результатов. Например, предварительная выборка объектов, на которые ссылается <code class="docutils literal notranslate"><span class="pre">GenericForeignKey</span></code>, поддерживается только в том случае, если запрос ограничен одним <code class="docutils literal notranslate"><span class="pre">ContentType</span></code>.</p>
<p>Например, предположим, у вас есть эти модели:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.db</span> <span class="k">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">Topping</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Pizza</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">toppings</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Topping</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;%s (%s)&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">topping</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">topping</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">toppings</span><span class="o">.</span><span class="n">all</span><span class="p">()),</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>и запустите:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Pizza</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">[&quot;Hawaiian (ham, pineapple)&quot;, &quot;Seafood (prawns, smoked salmon)&quot;...</span>
</pre></div>
</div>
<p>Проблема в том, что каждый раз, когда <code class="docutils literal notranslate"><span class="pre">Pizza.__str__()</span></code> запрашивает <code class="docutils literal notranslate"><span class="pre">self.toppings.all()</span></code>, он должен запросить базу данных, поэтому <code class="docutils literal notranslate"><span class="pre">Pizza.objects.all()</span></code> выполнит запрос к таблице Toppings для <strong>каждого</strong> элемента в Pizza <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>.</p>
<p>Мы можем сократить до двух запросов, используя <code class="docutils literal notranslate"><span class="pre">prefetch_related</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Pizza</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="s">&#39;toppings&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Это подразумевает <code class="docutils literal notranslate"><span class="pre">self.toppings.all()</span></code> для каждого <code class="docutils literal notranslate"><span class="pre">Pizza</span></code>; теперь каждый раз, когда вызывается <code class="docutils literal notranslate"><span class="pre">self.toppings.all()</span></code>, вместо того, чтобы обращаться к базе данных за элементами, он будет находить их в предварительно выбранном кэше <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, который был заполнен в одном запросе.</p>
<p>Таким образом, все соответствующие начинки будут извлечены в одном запросе и использованы для создания <code class="docutils literal notranslate"><span class="pre">QuerySets</span></code>, которые имеют предварительно заполненный кеш соответствующих результатов; эти <code class="docutils literal notranslate"><span class="pre">QuerySets</span></code> затем используются в вызовах <code class="docutils literal notranslate"><span class="pre">self.toppings.all()</span></code>.</p>
<p>Дополнительные запросы в <code class="docutils literal notranslate"><span class="pre">prefetch_related()</span></code> выполняются после того, как <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> начал оцениваться и был выполнен первичный запрос.</p>
<p>Если у вас есть итерация экземпляров модели, вы можете предварительно выбрать связанные атрибуты для этих экземпляров, используя функцию <a class="reference internal" href="#django.db.models.prefetch_related_objects" title="django.db.models.prefetch_related_objects"><code class="xref py py-func docutils literal notranslate"><span class="pre">prefetch_related_objects()</span></code></a>.</p>
<p>Обратите внимание, что кэш результатов первичного <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> и всех указанных связанных объектов будет полностью загружен в память. Это меняет типичное поведение <code class="docutils literal notranslate"><span class="pre">QuerySets</span></code>, которое обычно пытается избежать загрузки всех объектов в память до того, как они понадобятся, даже после выполнения запроса в базе данных.</p>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p>Помните, что, как всегда с <code class="docutils literal notranslate"><span class="pre">QuerySets</span></code>, любые последующие цепочечные методы, которые подразумевают другой запрос к базе данных, будут игнорировать ранее кэшированные результаты и извлекать данные, используя новый запрос к базе данных. Итак, если вы напишите следующее:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pizzas</span> <span class="o">=</span> <span class="n">Pizza</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="s">&#39;toppings&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">pizza</span><span class="o">.</span><span class="n">toppings</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">spicy</span><span class="o">=</span><span class="k">True</span><span class="p">))</span> <span class="k">for</span> <span class="n">pizza</span> <span class="ow">in</span> <span class="n">pizzas</span><span class="p">]</span>
</pre></div>
</div>
<p>…тогда тот факт, что <code class="docutils literal notranslate"><span class="pre">pizza.toppings.all()</span></code> был предварительно выбран, вам не поможет. <code class="docutils literal notranslate"><span class="pre">prefetch_related('toppings')</span></code> подразумевает <code class="docutils literal notranslate"><span class="pre">pizza.toppings.all()</span></code>, но <code class="docutils literal notranslate"><span class="pre">pizza.toppings.filter()</span></code> является новым и другим запросом. Предварительно выбранный кеш тут не поможет; на самом деле это снижает производительность, так как вы сделали запрос к базе данных, который вы не использовали. Так что используйте эту функцию с осторожностью!</p>
<p class="last">Также, если вы вызываете методы изменения базы данных <a class="reference internal" href="../relations/#django.db.models.fields.related.RelatedManager.add" title="django.db.models.fields.related.RelatedManager.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a>, <a class="reference internal" href="../relations/#django.db.models.fields.related.RelatedManager.remove" title="django.db.models.fields.related.RelatedManager.remove"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code></a>, <a class="reference internal" href="../relations/#django.db.models.fields.related.RelatedManager.clear" title="django.db.models.fields.related.RelatedManager.clear"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code></a> или <a class="reference internal" href="../relations/#django.db.models.fields.related.RelatedManager.set" title="django.db.models.fields.related.RelatedManager.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set()</span></code></a>, на <a class="reference internal" href="../relations/#django.db.models.fields.related.RelatedManager" title="django.db.models.fields.related.RelatedManager"><code class="xref py py-class docutils literal notranslate"><span class="pre">related</span> <span class="pre">managers</span></code></a>, любой предварительно выбранный кеш для отношения будет очищен.</p>
</div>
<p>Вы также можете использовать обычный синтаксис соединения, чтобы сделать связанные поля связанных полей. Предположим, у нас есть дополнительная модель к примеру выше:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Restaurant</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">pizzas</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Pizza</span><span class="p">,</span> <span class="n">related_name</span><span class="o">=</span><span class="s">&#39;restaurants&#39;</span><span class="p">)</span>
    <span class="n">best_pizza</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Pizza</span><span class="p">,</span> <span class="n">related_name</span><span class="o">=</span><span class="s">&#39;championed_by&#39;</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">)</span>
</pre></div>
</div>
<p>Следующее все законно:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="s">&#39;pizzas__toppings&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Это позволит предварительно выбрать все пиццы, принадлежащие ресторанам, и все начинки, принадлежащие этой пицце. В результате будет получено 3 запроса к базе данных - один для ресторанов, один для пиццы и один для начинки.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="s">&#39;best_pizza__toppings&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Это выберет лучшую пиццу и все начинки для лучшей пиццы для каждого ресторана. Это будет сделано в 3-х запросах к базе данных - один для ресторанов, один для «лучших пицц» и один для начинки.</p>
<p>Отношение <code class="docutils literal notranslate"><span class="pre">best_pizza</span></code> также может быть получено с использованием <code class="docutils literal notranslate"><span class="pre">select_related</span></code>, чтобы уменьшить количество запросов до 2:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">&#39;best_pizza&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="s">&#39;best_pizza__toppings&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Поскольку предварительная выборка выполняется после основного запроса (который включает соединения, необходимые для <code class="docutils literal notranslate"><span class="pre">select_related</span></code>), он может обнаружить, что объекты <code class="docutils literal notranslate"><span class="pre">best_pizza</span></code> уже были извлечены, и он пропустит их выборку снова.</p>
<p>Цепные вызовы <code class="docutils literal notranslate"><span class="pre">prefetch_related</span></code> будут накапливать предварительно выбранные поиски. Чтобы очистить любое поведение <code class="docutils literal notranslate"><span class="pre">prefetch_related</span></code>, передайте <code class="docutils literal notranslate"><span class="pre">None</span></code> в качестве параметра:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">non_prefetched</span> <span class="o">=</span> <span class="n">qs</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="k">None</span><span class="p">)</span>
</pre></div>
</div>
<p>При использовании <code class="docutils literal notranslate"><span class="pre">prefetch_related</span></code> следует отметить одно отличие, заключающееся в том, что объекты, созданные с помощью запроса, могут совместно использоваться различными объектами, с которыми они связаны, т.е. один экземпляр модели Python может появляться в нескольких точках дерева объектов, которые вернулись. Это обычно происходит с отношениями внешних ключей. Как правило, такое поведение не будет проблемой, и фактически сэкономит как память, так и время процессора.</p>
<p>Хотя <code class="docutils literal notranslate"><span class="pre">prefetch_related</span></code> поддерживает предварительную выборку отношений <code class="docutils literal notranslate"><span class="pre">GenericForeignKey</span></code>, количество запросов будет зависеть от данных. Поскольку <code class="docutils literal notranslate"><span class="pre">GenericForeignKey</span></code> может ссылаться на данные в нескольких таблицах, необходим один запрос для каждой таблицы, а не один запрос для всех элементов. Могут быть дополнительные запросы к таблице <code class="docutils literal notranslate"><span class="pre">ContentType</span></code>, если соответствующие строки еще не получены.</p>
<p><code class="docutils literal notranslate"><span class="pre">prefetch_related</span></code> в большинстве случаев будет реализован с использованием SQL-запроса, в котором используется оператор IN. Это означает, что для большого <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> может быть сгенерировано большое предложение „IN“, которое, в зависимости от базы данных, может иметь собственные проблемы с производительностью, когда дело доходит до синтаксического анализа или выполнения SQL-запроса. Всегда профилируйте то, что используете!</p>
<p>Обратите внимание, что если вы используете <code class="docutils literal notranslate"><span class="pre">iterator()</span></code> для выполнения запроса, <code class="docutils literal notranslate"><span class="pre">prefetch_related()</span></code> вызовы будут игнорироваться, так как эти две оптимизации не имеют смысла вместе.</p>
<p>Вы можете использовать объект <a class="reference internal" href="#django.db.models.Prefetch" title="django.db.models.Prefetch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Prefetch</span></code></a> для дальнейшего управления операцией предварительной выборки.</p>
<p>В своей простейшей форме <code class="docutils literal notranslate"><span class="pre">Prefetch</span></code> эквивалентен традиционным поискам на основе строк:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="k">import</span> <span class="n">Prefetch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;pizzas__toppings&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Вы можете предоставить пользовательский набор запросов с необязательным аргументом <code class="docutils literal notranslate"><span class="pre">queryset</span></code>. Это можно использовать для изменения порядка запросов по умолчанию:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;pizzas__toppings&#39;</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">Toppings</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">)))</span>
</pre></div>
</div>
<p>Или вызвать <a class="reference internal" href="#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_related()</span></code></a>, когда это применимо, чтобы еще больше сократить количество запросов:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Pizza</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;restaurants&#39;</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">&#39;best_pizza&#39;</span><span class="p">)))</span>
</pre></div>
</div>
<p>Вы также можете присвоить предварительно выбранный результат пользовательскому атрибуту с необязательным аргументом <code class="docutils literal notranslate"><span class="pre">to_attr</span></code>. Результат будет сохранен непосредственно в списке.</p>
<p>Это позволяет предварительно выбирать одно и то же отношение несколько раз с помощью другого <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, например:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vegetarian_pizzas</span> <span class="o">=</span> <span class="n">Pizza</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">vegetarian</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;pizzas&#39;</span><span class="p">,</span> <span class="n">to_attr</span><span class="o">=</span><span class="s">&#39;menu&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;pizzas&#39;</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">vegetarian_pizzas</span><span class="p">,</span> <span class="n">to_attr</span><span class="o">=</span><span class="s">&#39;vegetarian_menu&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Поиски, созданные с помощью пользовательского <code class="docutils literal notranslate"><span class="pre">to_attr</span></code>, по-прежнему могут просматриваться как обычно другими поисками:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vegetarian_pizzas</span> <span class="o">=</span> <span class="n">Pizza</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">vegetarian</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;pizzas&#39;</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">vegetarian_pizzas</span><span class="p">,</span> <span class="n">to_attr</span><span class="o">=</span><span class="s">&#39;vegetarian_menu&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="s">&#39;vegetarian_menu__toppings&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Использование <code class="docutils literal notranslate"><span class="pre">to_attr</span></code> рекомендуется при фильтрации результата предварительной выборки, поскольку он менее неоднозначен, чем сохранение отфильтрованного результата в кеше соответствующего менеджера:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">queryset</span> <span class="o">=</span> <span class="n">Pizza</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">vegetarian</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Recommended:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">restaurants</span> <span class="o">=</span> <span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;pizzas&#39;</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">queryset</span><span class="p">,</span> <span class="n">to_attr</span><span class="o">=</span><span class="s">&#39;vegetarian_pizzas&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vegetarian_pizzas</span> <span class="o">=</span> <span class="n">restaurants</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vegetarian_pizzas</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Not recommended:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">restaurants</span> <span class="o">=</span> <span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;pizzas&#39;</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">queryset</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vegetarian_pizzas</span> <span class="o">=</span> <span class="n">restaurants</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pizzas</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>Пользовательская предварительная выборка также работает с отдельными связанными отношениями, такими как прямой <code class="docutils literal notranslate"><span class="pre">ForeignKey</span></code> или <code class="docutils literal notranslate"><span class="pre">OneToOneField</span></code>. Обычно вы хотите использовать <a class="reference internal" href="#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_related()</span></code></a> для этих отношений, но есть ряд случаев, когда полезна предварительная выборка с помощью пользовательского <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>:</p>
<ul>
<li><p class="first">Вы хотите использовать <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, который выполняет дальнейшую предварительную выборку для связанных моделей.</p>
</li>
<li><p class="first">Вы хотите предварительно выбрать только подмножество связанных объектов.</p>
</li>
<li><p class="first">Вы хотите использовать методы оптимизации производительности, такие как <a class="reference internal" href="#django.db.models.query.QuerySet.defer" title="django.db.models.query.QuerySet.defer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">отложенные</span> <span class="pre">поля</span></code></a>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">queryset</span> <span class="o">=</span> <span class="n">Pizza</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">restaurants</span> <span class="o">=</span> <span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;best_pizza&#39;</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">queryset</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
<p>При использовании нескольких баз данных функция предварительной выборки учитывает ваш выбор базы данных. Если во внутреннем запросе не указана база данных, он будет использовать базу данных, выбранную внешним запросом. Все следующие действительны:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Both inner and outer queries will use the &#39;replica&#39; database</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="s">&#39;pizzas__toppings&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">using</span><span class="p">(</span><span class="s">&#39;replica&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;pizzas__toppings&#39;</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">using</span><span class="p">(</span><span class="s">&#39;replica&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Inner will use the &#39;replica&#39; database; outer will use &#39;default&#39; database</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;pizzas__toppings&#39;</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">Toppings</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">using</span><span class="p">(</span><span class="s">&#39;replica&#39;</span><span class="p">)),</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Inner will use &#39;replica&#39; database; outer will use &#39;cold-storage&#39; database</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;pizzas__toppings&#39;</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">Toppings</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">using</span><span class="p">(</span><span class="s">&#39;replica&#39;</span><span class="p">)),</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">using</span><span class="p">(</span><span class="s">&#39;cold-storage&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p>Сортировка поисков имеет значение.</p>
<p>Возьмите следующие примеры:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">prefetch_related</span><span class="p">(</span><span class="s">&#39;pizzas__toppings&#39;</span><span class="p">,</span> <span class="s">&#39;pizzas&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Это работает, даже если он неупорядочен, потому что <code class="docutils literal notranslate"><span class="pre">'pizzas__toppings'</span></code> уже содержит всю необходимую информацию, поэтому второй аргумент <code class="docutils literal notranslate"><span class="pre">'pizzas'</span></code> на самом деле является избыточным.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">prefetch_related</span><span class="p">(</span><span class="s">&#39;pizzas__toppings&#39;</span><span class="p">,</span> <span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;pizzas&#39;</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">Pizza</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()))</span>
</pre></div>
</div>
<p>Это вызовет <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> из-за попытки переопределить набор запросов ранее увиденного поиска. Обратите внимание, что неявный набор запросов был создан для прохождения <code class="docutils literal notranslate"><span class="pre">'pizzas'</span></code> как часть поиска <code class="docutils literal notranslate"><span class="pre">'pizzas__toppings'</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">prefetch_related</span><span class="p">(</span><span class="s">&#39;pizza_list__toppings&#39;</span><span class="p">,</span> <span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;pizzas&#39;</span><span class="p">,</span> <span class="n">to_attr</span><span class="o">=</span><span class="s">&#39;pizza_list&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Это вызовет <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code>, потому что <code class="docutils literal notranslate"><span class="pre">'pizza_list'</span></code> еще не существует, когда обрабатывается <code class="docutils literal notranslate"><span class="pre">'pizza_list__toppings'</span></code>.</p>
<p class="last">Это соображение не ограничивается использованием объектов <code class="docutils literal notranslate"><span class="pre">Prefetch</span></code>. Некоторые передовые методы могут требовать, чтобы поиск выполнялся в определенном порядке, чтобы избежать создания дополнительных запросов; поэтому рекомендуется всегда тщательно упорядочивать аргументы <code class="docutils literal notranslate"><span class="pre">prefetch_related</span></code>.</p>
</div>
</div>
<div class="df-ads">
    <!-- Yandex.RTB R-A-395615-12 -->
    <div id="yandex_rtb_R-A-395615-12"></div>
    <script type="text/javascript">
        (function(w, d, n, s, t) {
            w[n] = w[n] || [];
            w[n].push(function() {
                Ya.Context.AdvManager.render({
                    blockId: "R-A-395615-12",
                    renderTo: "yandex_rtb_R-A-395615-12",
                    async: true
                });
            });
            t = d.getElementsByTagName("script")[0];
            s = d.createElement("script");
            s.type = "text/javascript";
            s.src = "//an.yandex.ru/system/context.js";
            s.async = true;
            t.parentNode.insertBefore(s, t);
        })(this, this.document, "yandexContextAsyncCallbacks");
    </script>
    </div><div class="section" id="s-extra">
<span id="extra"></span><h4><code class="docutils literal notranslate"><span class="pre">extra()</span></code><a class="headerlink" href="#extra" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.extra">
<code class="descname">extra</code>(<em><span class="n">select</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">where</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">params</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">tables</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">order_by</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">select_params</span><span class="o">=</span><span class="default_value">None</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.extra" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Иногда синтаксис запроса Django сам по себе не может легко выразить сложное предложение <code class="docutils literal notranslate"><span class="pre">WHERE</span></code>. Для этих крайних случаев Django предоставляет модификатор <code class="docutils literal notranslate"><span class="pre">extra()</span></code> <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> - ловушку для вставки определенных предложений в SQL, генерируемый <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>.</p>
<div class="admonition-use-this-method-as-a-last-resort admonition">
<p class="first admonition-title">Используйте этот метод в качестве крайней меры</p>
<p>Это старый API, который мы запретим в какой-то момент в будущем. Используйте его, только если вы не можете выразить свой запрос, используя другие методы набора запросов. Если вам нужно его использовать, пожалуйста, отправьте заявку &lt;<a class="reference external" href="https://code.djangoproject.com/newticket">https://code.djangoproject.com/newticket</a>&gt;`_, используя ключевое слово <a class="reference external" href="https://code.djangoproject.com/query?status=assigned&amp;status=new&amp;keywords=~QuerySet.extra">QuerySet.extra keyword</a> в вашем случае использования (сначала проверьте список существующих заявок), чтобы мы могли усовершенствовать API QuerySet, чтобы разрешить удаление <code class="docutils literal notranslate"><span class="pre">extra()</span></code>. Мы больше не улучшаем и не исправляем ошибки для этого метода.</p>
<p>Например, это использование <code class="docutils literal notranslate"><span class="pre">extra()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qs</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">select</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;val&#39;</span><span class="p">:</span> <span class="s">&quot;select col from sometable where othercol = %s&quot;</span><span class="p">},</span>
<span class="gp">... </span>    <span class="n">select_params</span><span class="o">=</span><span class="p">(</span><span class="n">someparam</span><span class="p">,),</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>эквивалентно:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qs</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="n">RawSQL</span><span class="p">(</span><span class="s">&quot;select col from sometable where othercol = %s&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">someparam</span><span class="p">,)))</span>
</pre></div>
</div>
<p class="last">Основное преимущество использования <a class="reference internal" href="../expressions/#django.db.models.expressions.RawSQL" title="django.db.models.expressions.RawSQL"><code class="xref py py-class docutils literal notranslate"><span class="pre">RawSQL</span></code></a> заключается в том, что при необходимости вы можете установить <code class="docutils literal notranslate"><span class="pre">output_field</span></code>. Основным недостатком является то, что если вы ссылаетесь на какой-либо псевдоним таблицы в наборе запросов в необработанном SQL, возможно, что Django может изменить этот псевдоним (например, когда набор запросов используется в качестве подзапроса в еще одном запросе).</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p>Вы должны быть очень осторожны, когда используете <code class="docutils literal notranslate"><span class="pre">extra()</span></code>. Каждый раз, когда вы используете его, вы должны избегать любых параметров, которыми пользователь может управлять, используя <code class="docutils literal notranslate"><span class="pre">params</span></code> для защиты от атак SQL-инъекций.</p>
<p>Вы также не должны заключать заполнители в кавычки в строке SQL. Этот пример уязвим для внедрения SQL из-за кавычек вокруг <code class="docutils literal notranslate"><span class="pre">%s</span></code>:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="n">col</span> <span class="k">FROM</span> <span class="n">sometable</span> <span class="k">WHERE</span> <span class="n">othercol</span> <span class="o">=</span> <span class="s1">&#39;%s&#39;</span>  <span class="o">#</span> <span class="n">unsafe</span><span class="o">!</span>
</pre></div>
</div>
<p class="last">Вы можете прочитать больше о том, как работает в Django <a class="reference internal" href="../../../topics/security/#sql-injection-protection"><span class="std std-ref">Защита от SQL-инъекций</span></a>.</p>
</div>
<p>По определению, эти дополнительные поиски могут не переноситься на разные механизмы баз данных (потому что вы явно пишете код SQL) и нарушают принцип DRY, поэтому вам следует избегать их, если это возможно.</p>
<p>Укажите одну или несколько <code class="docutils literal notranslate"><span class="pre">params</span></code>, <code class="docutils literal notranslate"><span class="pre">select</span></code>, <code class="docutils literal notranslate"><span class="pre">where</span></code> или <code class="docutils literal notranslate"><span class="pre">tables</span></code>. Ни один из аргументов не требуется, но вы должны использовать хотя бы один из них.</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">select</span></code></p>
<p>Аргумент <code class="docutils literal notranslate"><span class="pre">select</span></code> позволяет добавлять дополнительные поля в предложение <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>. Это должен быть словарь, сопоставляющий имена атрибутов с предложениями SQL для использования для вычисления этого атрибута.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">select</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;is_recent&#39;</span><span class="p">:</span> <span class="s">&quot;pub_date &gt; &#39;2006-01-01&#39;&quot;</span><span class="p">})</span>
</pre></div>
</div>
<p>В результате каждый объект <code class="docutils literal notranslate"><span class="pre">Entry</span></code> будет иметь дополнительный атрибут, <code class="docutils literal notranslate"><span class="pre">is_recent</span></code>, логическое значение, представляющее, является ли <code class="docutils literal notranslate"><span class="pre">pub_date</span></code> больше, чем 1 января 2006 года.</p>
<p>Django вставляет данный фрагмент SQL непосредственно в оператор <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>, поэтому полученный SQL-код из приведенного выше примера будет выглядеть примерно так:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="n">blog_entry</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="p">(</span><span class="n">pub_date</span> <span class="o">&gt;</span> <span class="s1">&#39;2006-01-01&#39;</span><span class="p">)</span> <span class="k">AS</span> <span class="n">is_recent</span>
<span class="k">FROM</span> <span class="n">blog_entry</span><span class="p">;</span>
</pre></div>
</div>
<p>Следующий пример более продвинутый, он выполняет подзапрос, чтобы дать каждому результирующему объекту <code class="docutils literal notranslate"><span class="pre">Blog</span></code> атрибут <code class="docutils literal notranslate"><span class="pre">entry_count</span></code>, целое число связанных объектов <code class="docutils literal notranslate"><span class="pre">Entry</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
    <span class="n">select</span><span class="o">=</span><span class="p">{</span>
        <span class="s">&#39;entry_count&#39;</span><span class="p">:</span> <span class="s">&#39;SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id&#39;</span>
    <span class="p">},</span>
<span class="p">)</span>
</pre></div>
</div>
<p>В данном конкретном случае мы используем тот факт, что запрос уже содержит таблицу <code class="docutils literal notranslate"><span class="pre">blog_blog</span></code> в своем предложении <code class="docutils literal notranslate"><span class="pre">FROM</span></code>.</p>
<p>Результирующий SQL из приведенного выше примера будет:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="n">blog_blog</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">blog_entry</span> <span class="k">WHERE</span> <span class="n">blog_entry</span><span class="p">.</span><span class="n">blog_id</span> <span class="o">=</span> <span class="n">blog_blog</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="k">AS</span> <span class="n">entry_count</span>
<span class="k">FROM</span> <span class="n">blog_blog</span><span class="p">;</span>
</pre></div>
</div>
<p>Обратите внимание, что круглые скобки, требуемые большинством механизмов баз данных для подзапросов, не требуются в предложениях <code class="docutils literal notranslate"><span class="pre">select</span></code> Django. Также обратите внимание, что некоторые базы данных, такие как некоторые версии MySQL, не поддерживают подзапросы.</p>
<p>В некоторых редких случаях вам может потребоваться передать параметры фрагментам SQL в <code class="docutils literal notranslate"><span class="pre">extra(select=...)</span></code>. Для этого используйте параметр <code class="docutils literal notranslate"><span class="pre">select_params</span></code>.</p>
<p>Это будет работать, например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span>
    <span class="n">select</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="s">&#39;%s&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="s">&#39;%s&#39;</span><span class="p">},</span>
    <span class="n">select_params</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;one&#39;</span><span class="p">,</span> <span class="s">&#39;two&#39;</span><span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Если вам нужно использовать литерал <code class="docutils literal notranslate"><span class="pre">%s</span></code> внутри строки выбора, используйте последовательность <code class="docutils literal notranslate"><span class="pre">%%s</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">where</span></code> / <code class="docutils literal notranslate"><span class="pre">tables</span></code></p>
<p>Вы можете определить явные выражения SQL <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> - возможно, для выполнения неявных объединений - используя <code class="docutils literal notranslate"><span class="pre">where</span></code>. Вы можете вручную добавить таблицы в предложение SQL <code class="docutils literal notranslate"><span class="pre">FROM</span></code>, используя <code class="docutils literal notranslate"><span class="pre">tables</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">where</span></code> и <code class="docutils literal notranslate"><span class="pre">tables</span></code> принимают список строк. Все <code class="docutils literal notranslate"><span class="pre">where</span></code> параметры имеют значение «AND» для любых других критериев поиска.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;foo=&#39;a&#39; OR bar = &#39;a&#39;&quot;</span><span class="p">,</span> <span class="s">&quot;baz = &#39;a&#39;&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>…переводит (примерно) в следующий SQL:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">blog_entry</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">foo</span><span class="o">=</span><span class="s1">&#39;a&#39;</span> <span class="k">OR</span> <span class="n">bar</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">AND</span> <span class="p">(</span><span class="n">baz</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Будьте осторожны при использовании параметра <code class="docutils literal notranslate"><span class="pre">tables</span></code>, если вы указываете таблицы, которые уже используются в запросе. Когда вы добавляете дополнительные таблицы с помощью параметра <code class="docutils literal notranslate"><span class="pre">tables</span></code>, Django предполагает, что вы хотите, чтобы таблица включала дополнительное время, если оно уже включено. Это создает проблему, так как имя таблицы будет иметь псевдоним. Если таблица появляется в операторе SQL несколько раз, второе и последующие вхождения должны использовать псевдонимы, чтобы база данных могла различать их. Если вы ссылаетесь на дополнительную таблицу, которую вы добавили в дополнительный параметр <code class="docutils literal notranslate"><span class="pre">where</span></code>, это приведет к ошибкам.</p>
<p>Обычно вы будете добавлять только дополнительные таблицы, которые еще не отображаются в запросе. Однако, если описанный выше случай действительно имеет место, есть несколько решений. Во-первых, посмотрите, сможете ли вы обойтись без включения дополнительной таблицы и используйте ту, которая уже есть в запросе. Если это невозможно, поместите ваш вызов <code class="docutils literal notranslate"><span class="pre">extra()</span></code> в начале конструкции набора запросов, чтобы ваша таблица использовалась первой в этой таблице. Наконец, если ничего не помогает, посмотрите на полученный запрос и перепишите свое дополнение <code class="docutils literal notranslate"><span class="pre">where</span></code>, чтобы использовать псевдоним, указанный в вашей дополнительной таблице. Псевдоним будет одинаковым каждый раз, когда вы создаете набор запросов одинаковым образом, поэтому вы можете положиться на имя псевдонима, которое не изменится.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">order_by</span></code></p>
<p>Если вам нужно упорядочить результирующий набор запросов, используя некоторые из новых полей или таблиц, которые вы включили через <code class="docutils literal notranslate"><span class="pre">extra()</span></code>, используйте параметр <code class="docutils literal notranslate"><span class="pre">order_by</span></code> для <code class="docutils literal notranslate"><span class="pre">extra()</span></code> и передайте последовательность строк. Эти строки должны быть либо полями модели (как в обычном методе <a class="reference internal" href="#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">order_by()</span></code></a> для наборов запросов), формы <code class="docutils literal notranslate"><span class="pre">table_name.column_name</span></code> или псевдонимом для столбца, который вы указали в <code class="docutils literal notranslate"><span class="pre">select</span></code> параметре для <code class="docutils literal notranslate"><span class="pre">extra()</span></code>.</p>
<p>Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">q</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">select</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;is_recent&#39;</span><span class="p">:</span> <span class="s">&quot;pub_date &gt; &#39;2006-01-01&#39;&quot;</span><span class="p">})</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">order_by</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;-is_recent&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Это отсортировало бы все элементы, для которых <code class="docutils literal notranslate"><span class="pre">is_recent</span></code> является верным в начало набора результатов (<code class="docutils literal notranslate"><span class="pre">True</span></code> сортирует перед <code class="docutils literal notranslate"><span class="pre">False</span></code> в порядке убывания).</p>
<p>Между прочим, это показывает, что вы можете сделать несколько вызовов <code class="docutils literal notranslate"><span class="pre">extra()</span></code>, и он будет вести себя так, как вы ожидаете (добавляя новые ограничения каждый раз).</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">params</span></code></p>
<p>Описанный выше параметр <code class="docutils literal notranslate"><span class="pre">where</span></code> может использовать стандартные строковые заполнители базы данных Python - <code class="docutils literal notranslate"><span class="pre">'%s'</span></code> для указания параметров, которые механизм базы данных должен автоматически заключать в кавычки. Аргумент <code class="docutils literal notranslate"><span class="pre">params</span></code> - это список любых дополнительных параметров, которые нужно заменить.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;headline=%s&#39;</span><span class="p">],</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;Lennon&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Всегда используйте <code class="docutils literal notranslate"><span class="pre">params</span></code> вместо встраивания значений непосредственно в <code class="docutils literal notranslate"><span class="pre">where</span></code>, потому что <code class="docutils literal notranslate"><span class="pre">params</span></code> обеспечит правильное экранирование значений в соответствии с вашим конкретным бэкэндом. Например, кавычки будут экранированы правильно.</p>
<p>Плохо:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;headline=&#39;Lennon&#39;&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Хорошо:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extra</span><span class="p">(</span><span class="n">where</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;headline=%s&#39;</span><span class="p">],</span> <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;Lennon&#39;</span><span class="p">])</span>
</pre></div>
</div>
</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p class="last">Если вы выполняете запросы к MySQL, обратите внимание, что принудительное приведение типов в MySQL может привести к неожиданным результатам при смешивании типов. Если вы запрашиваете столбец строкового типа, но с целочисленным значением, MySQL перед выполнением сравнения преобразует типы всех значений в таблице в целое число. Например, если ваша таблица содержит значения <code class="docutils literal notranslate"><span class="pre">'abc'</span></code>, <code class="docutils literal notranslate"><span class="pre">'def'</span></code> и вы запрашиваете <code class="docutils literal notranslate"><span class="pre">WHERE</span> <span class="pre">mycolumn=0</span></code>, обе строки будут совпадать. Чтобы предотвратить это, выполните правильное приведение типов перед использованием значения в запросе.</p>
</div>
</div>
<div class="section" id="s-defer">
<span id="defer"></span><h4><code class="docutils literal notranslate"><span class="pre">defer()</span></code><a class="headerlink" href="#defer" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.defer">
<code class="descname">defer</code>(<em><span class="o">*</span><span class="n">fields</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.defer" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>В некоторых сложных ситуациях моделирования данных ваши модели могут содержать много полей, некоторые из которых могут содержать много данных (например, текстовые поля), или требовать дорогостоящей обработки для преобразования их в объекты Python. Если вы используете результаты набора запросов в какой-то ситуации, когда вы не знаете, нужны ли вам эти конкретные поля при первоначальном извлечении данных, вы можете указать Django не извлекать их из базы данных.</p>
<p>Это делается путем передачи имен полей, которые не загружаются, в <code class="docutils literal notranslate"><span class="pre">defer()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="s">&quot;headline&quot;</span><span class="p">,</span> <span class="s">&quot;body&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Набор запросов с отложенными полями будет по-прежнему возвращать экземпляры модели. Каждое отложенное поле будет извлечено из базы данных, если вы получите доступ к этому полю (по одному, а не ко всем отложенным полям одновременно).</p>
<p>Вы можете сделать несколько вызовов <code class="docutils literal notranslate"><span class="pre">defer()</span></code>. Каждый вызов добавляет новые поля в отложенный набор:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="c"># Defers both the body and headline fields.</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="s">&quot;body&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">rating</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="s">&quot;headline&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Порядок, в котором поля добавляются в отложенный набор, не имеет значения. Вызов <code class="docutils literal notranslate"><span class="pre">defer()</span></code> с именем поля, которое уже было отложено, безвреден (поле все равно будет отложено).</p>
<p>Вы можете отложить загрузку полей в связанных моделях (если связанные модели загружаются через <a class="reference internal" href="#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_related()</span></code></a>), используя стандартную запись двойного подчеркивания для разделения связанных полей:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">()</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="s">&quot;entry__headline&quot;</span><span class="p">,</span> <span class="s">&quot;entry__body&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Если вы хотите очистить набор отложенных полей, передайте <code class="docutils literal notranslate"><span class="pre">None</span></code> в качестве параметра в <code class="docutils literal notranslate"><span class="pre">defer()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="c"># Load all fields immediately.</span>
<span class="n">my_queryset</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="k">None</span><span class="p">)</span>
</pre></div>
</div>
<p>Некоторые поля в модели не будут отложены, даже если вы укажете их. Вы никогда не сможете отложить загрузку первичного ключа. Если вы используете <a class="reference internal" href="#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_related()</span></code></a> для извлечения связанных моделей, вы не должны откладывать загрузку поля, соединяющего основную модель с связанной, это приведет к ошибке.</p>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p>Метод <code class="docutils literal notranslate"><span class="pre">defer()</span></code> (и его двоюродный брат <a class="reference internal" href="#django.db.models.query.QuerySet.only" title="django.db.models.query.QuerySet.only"><code class="xref py py-meth docutils literal notranslate"><span class="pre">only()</span></code></a>, ниже) предназначены только для расширенных вариантов использования. Они обеспечивают оптимизацию, когда вы тщательно проанализировали свои запросы и <em>точно</em> поняли, какая информация вам нужна, и измерили, что разница между возвратом необходимых вам полей и полным набором полей для модели будет значительной.</p>
<p>Даже если вы думаете, что находитесь в расширенной ситуации варианта использования, <strong>используйте defer() только тогда, когда вы не можете во время загрузки набора запросов определить, нужны ли вам дополнительные поля или нет</strong>. Если вы часто загружаете и используете определенное подмножество ваших данных, лучший выбор, который вы можете сделать, - это нормализовать ваши модели и поместить незагруженные данные в отдельную модель (и таблицу базы данных). Если столбцы <em>должны</em> по какой-то причине оставаться в одной таблице, создайте модель с <code class="docutils literal notranslate"><span class="pre">Meta.managed=False</span></code> (смотрите документацию <a class="reference internal" href="../options/#django.db.models.Options.managed" title="django.db.models.Options.managed"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Управляемый</span> <span class="pre">атрибут</span></code></a>) содержит только те поля, которые вы обычно должны загрузить и использовать там, где вы могли бы иначе вызвать <code class="docutils literal notranslate"><span class="pre">defer()</span></code>. Это делает ваш код более понятным для читателя, немного быстрее и потребляет немного меньше памяти в процессе Python.</p>
<p>Например, обе эти модели используют одну и ту же базовую таблицу базы данных:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CommonlyUsedModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">managed</span> <span class="o">=</span> <span class="k">False</span>
        <span class="n">db_table</span> <span class="o">=</span> <span class="s">&#39;app_largetable&#39;</span>

<span class="k">class</span> <span class="nc">ManagedModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">db_table</span> <span class="o">=</span> <span class="s">&#39;app_largetable&#39;</span>

<span class="c"># Two equivalent QuerySets:</span>
<span class="n">CommonlyUsedModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="n">ManagedModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="s">&#39;f2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">Если в неуправляемой модели необходимо дублировать многие поля, может быть лучше создать абстрактную модель с общими полями, а затем иметь неуправляемые и управляемые модели, наследуемые от абстрактной модели.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p class="last">При вызове <a class="reference internal" href="../instances/#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> для экземпляров с отложенными полями будут сохранены только загруженные поля. Смотрите <a class="reference internal" href="../instances/#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> для более подробной информации.</p>
</div>
</div>
<div class="section" id="s-only">
<span id="only"></span><h4><code class="docutils literal notranslate"><span class="pre">only()</span></code><a class="headerlink" href="#only" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.only">
<code class="descname">only</code>(<em><span class="o">*</span><span class="n">fields</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.only" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Метод <code class="docutils literal notranslate"><span class="pre">only()</span></code> более или менее противоположен <a class="reference internal" href="#django.db.models.query.QuerySet.defer" title="django.db.models.query.QuerySet.defer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">defer()</span></code></a>. Вы вызываете его с полями, которые <em>не</em> должны быть отложены при получении модели. Если у вас есть модель, в которой почти все поля необходимо отложить, использование <code class="docutils literal notranslate"><span class="pre">only()</span></code> для указания дополнительного набора полей может привести к упрощению кода.</p>
<p>Предположим, у вас есть модель с полями <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">age</span></code> и <code class="docutils literal notranslate"><span class="pre">biography</span></code>. Следующие два набора запросов одинаковы с точки зрения отложенных полей:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="s">&quot;age&quot;</span><span class="p">,</span> <span class="s">&quot;biography&quot;</span><span class="p">)</span>
<span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Всякий раз, когда вы вызываете <code class="docutils literal notranslate"><span class="pre">only()</span></code>, он <em>заменяет</em> набор полей для немедленной загрузки. Имя метода мнемоническое: <strong>только</strong> эти поля загружаются немедленно. Остальные откладываются. Таким образом, последовательные вызовы <code class="docutils literal notranslate"><span class="pre">only()</span></code> приводят только к рассмотрению последних полей:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="c"># This will defer all fields except the headline.</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="s">&quot;body&quot;</span><span class="p">,</span> <span class="s">&quot;rating&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="s">&quot;headline&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Поскольку <code class="docutils literal notranslate"><span class="pre">defer()</span></code> действует постепенно (добавляя поля в отложенный список), вы можете комбинировать вызовы <code class="docutils literal notranslate"><span class="pre">only()</span></code> и <code class="docutils literal notranslate"><span class="pre">defer()</span></code>, и все будет вести себя логически:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="c"># Final result is that everything except &quot;headline&quot; is deferred.</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="s">&quot;headline&quot;</span><span class="p">,</span> <span class="s">&quot;body&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="s">&quot;body&quot;</span><span class="p">)</span>

<span class="c"># Final result loads headline and body immediately (only() replaces any</span>
<span class="c"># existing set of fields).</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">defer</span><span class="p">(</span><span class="s">&quot;body&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">only</span><span class="p">(</span><span class="s">&quot;headline&quot;</span><span class="p">,</span> <span class="s">&quot;body&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Все предостережения в примечании к документации <a class="reference internal" href="#django.db.models.query.QuerySet.defer" title="django.db.models.query.QuerySet.defer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">defer()</span></code></a> относятся и к <code class="docutils literal notranslate"><span class="pre">only()</span></code>. Используйте его осторожно и только после того, как исчерпаете ваши другие возможности.</p>
<p>Использование <a class="reference internal" href="#django.db.models.query.QuerySet.only" title="django.db.models.query.QuerySet.only"><code class="xref py py-meth docutils literal notranslate"><span class="pre">only()</span></code></a> и пропуск поля, запрошенного с использованием <a class="reference internal" href="#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_related()</span></code></a>, также является ошибкой.</p>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p class="last">При вызове <a class="reference internal" href="../instances/#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> для экземпляров с отложенными полями будут сохранены только загруженные поля. Смотрите <a class="reference internal" href="../instances/#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> для более подробной информации.</p>
</div>
</div>
<div class="section" id="s-using">
<span id="using"></span><h4><code class="docutils literal notranslate"><span class="pre">using()</span></code><a class="headerlink" href="#using" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.using">
<code class="descname">using</code>(<em><span class="n">alias</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.using" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Этот метод предназначен для указания какую базу данных <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> будет использовать, если вы используете более одной базы данных. Единственный аргумент, который принимает этот метод - это псевдоним базы данных, как определено в <a class="reference internal" href="../../settings/#std-setting-DATABASES"><code class="xref std std-setting docutils literal notranslate"><span class="pre">DATABASES</span></code></a>.</p>
<p>Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="c"># queries the database with the &#39;default&#39; alias.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c"># queries the database with the &#39;backup&#39; alias</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">using</span><span class="p">(</span><span class="s">&#39;backup&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="s-select-for-update">
<span id="select-for-update"></span><h4><code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code><a class="headerlink" href="#select-for-update" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.select_for_update">
<code class="descname">select_for_update</code>(<em><span class="n">nowait</span><span class="o">=</span><span class="default_value">False</span></em>, <em><span class="n">skip_locked</span><span class="o">=</span><span class="default_value">False</span></em>, <em><span class="n">of</span><span class="o">=</span><span class="default_value">()</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.select_for_update" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает набор запросов, который блокирует строки до конца транзакции, генерируя оператор SQL <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">...</span> <span class="pre">FOR</span> <span class="pre">UPDATE</span></code> для поддерживаемых баз данных.</p>
<p>Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.db</span> <span class="k">import</span> <span class="n">transaction</span>

<span class="n">entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_for_update</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">author</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>
<span class="k">with</span> <span class="n">transaction</span><span class="o">.</span><span class="n">atomic</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>Когда набор запросов выполняется (в данном случае <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">entry</span> <span class="pre">in</span> <span class="pre">entries</span></code>), все совпадающие записи будут заблокированы до конца блока транзакции, что означает, что другие транзакции не смогут изменить или получить блокировки для них.</p>
<p>Обычно, если другая транзакция уже получила блокировку в одной из выбранных строк, запрос будет блокироваться до тех пор, пока блокировка не будет снята. Если это не то поведение, которое вам нужно, вызовите <code class="docutils literal notranslate"><span class="pre">select_for_update(nowait=True)</span></code>. Это сделает вызов неблокирующим. Если конфликтующая блокировка уже получена другой транзакцией, то при оценке набора запросов будет вызвано <a class="reference internal" href="../../exceptions/#django.db.DatabaseError" title="django.db.DatabaseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DatabaseError</span></code></a>. Вы также можете игнорировать заблокированные строки, используя <code class="docutils literal notranslate"><span class="pre">select_for_update(skip_locked=True)</span></code>. <code class="docutils literal notranslate"><span class="pre">nowait</span></code> и <code class="docutils literal notranslate"><span class="pre">skip_locked</span></code> являются взаимоисключающими и попытки вызвать <code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code> с включенными обеими опциями приведут к <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(в Python v3.9)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>.</p>
<p>По умолчанию <code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code> блокирует все строки, выбранные запросом. Например, строки связанных объектов, указанных в <a class="reference internal" href="#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_related()</span></code></a>, блокируются в дополнение к строкам модели набора запросов. Если это нежелательно, укажите связанные объекты, которые вы хотите заблокировать, в <code class="docutils literal notranslate"><span class="pre">select_for_update(of=(...))</span></code>, используя тот же синтаксис полей, что и <a class="reference internal" href="#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_related()</span></code></a>. Используйте значение <code class="docutils literal notranslate"><span class="pre">'self'</span></code> для ссылки на модель набора запросов.</p>
<div class="admonition-lock-parents-models-in-select-for-update-of admonition">
<p class="first admonition-title">Блокировка родительских моделей в <code class="docutils literal notranslate"><span class="pre">select_for_update(of=(...))</span></code></p>
<p>Если вы хотите заблокировать родительские модели при использовании <a class="reference internal" href="../../../topics/db/models/#multi-table-inheritance"><span class="std std-ref">наследование нескольких таблиц</span></a>, вы должны указать поля родительской ссылки (по умолчанию <code class="docutils literal notranslate"><span class="pre">&lt;parent_model_name&gt;_ptr</span></code>) в аргументе <code class="docutils literal notranslate"><span class="pre">of</span></code>. Например:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_for_update</span><span class="p">(</span><span class="n">of</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;self&#39;</span><span class="p">,</span> <span class="s">&#39;place_ptr&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>Вы не можете использовать <code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code> для обнуляемых отношений:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">&#39;hometown&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">select_for_update</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">django.db.utils.NotSupportedError</span>: <span class="n">FOR UPDATE cannot be applied to the nullable side of an outer join</span>
</pre></div>
</div>
<p>Чтобы избежать этого ограничения, вы можете исключить нулевые объекты, если вам не нужны их значения:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">&#39;hometown&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">select_for_update</span><span class="p">()</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">hometown</span><span class="o">=</span><span class="k">None</span><span class="p">)</span>
<span class="go">&lt;QuerySet [&lt;Person: ...)&gt;, ...]&gt;</span>
</pre></div>
</div>
<p>В настоящее время серверные базы данных <code class="docutils literal notranslate"><span class="pre">postgresql</span></code>, <code class="docutils literal notranslate"><span class="pre">oracle</span></code> и <code class="docutils literal notranslate"><span class="pre">mysql</span></code> поддерживают <code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code>. Однако MariaDB 10.3+ поддерживает только аргумент <code class="docutils literal notranslate"><span class="pre">nowait</span></code>, а MySQL 8.0.1+ поддерживает аргументы <code class="docutils literal notranslate"><span class="pre">nowait</span></code> и <code class="docutils literal notranslate"><span class="pre">skip_locked</span></code>. MySQL и MariaDB не поддерживают аргумент <code class="docutils literal notranslate"><span class="pre">of</span></code>.</p>
<p>Передача <code class="docutils literal notranslate"><span class="pre">nowait=True</span></code>, <code class="docutils literal notranslate"><span class="pre">skip_locked=True</span></code> или <code class="docutils literal notranslate"><span class="pre">of</span></code> в <code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code> с использованием бэкэндов базы данных, которые не поддерживают эти опции, такие как MySQL, вызывает <a class="reference internal" href="../../exceptions/#django.db.NotSupportedError" title="django.db.NotSupportedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotSupportedError</span></code></a>. Это предотвращает неожиданную блокировку кода.</p>
<p>Оценка набора запросов с помощью <code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code> в режиме автоматической фиксации на бэкэндах, которые поддерживают <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">...</span> <span class="pre">FOR</span> <span class="pre">UPDATE</span></code>, является ошибкой <a class="reference internal" href="../../exceptions/#django.db.transaction.TransactionManagementError" title="django.db.transaction.TransactionManagementError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TransactionManagementError</span></code></a>, поскольку строки не заблокированы в этом случае. Если это разрешено, это будет способствовать повреждению данных и может быть легко вызвано вызовом кода, который предполагается запустить в транзакции вне ее.</p>
<p>Использование <code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code> на бэкэндах, которые не поддерживают <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">...</span> <span class="pre">FOR</span> <span class="pre">UPDATE</span></code> (таких как SQLite), не будет иметь никакого эффекта. <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">...</span> <span class="pre">FOR</span> <span class="pre">UPDATE</span></code> не будет добавлен к запросу, и ошибка не возникнет, если <code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code> используется в режиме автоматической фиксации.</p>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p class="last">Хотя <code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code> обычно дает сбой в режиме автоматической фиксации, поскольку <a class="reference internal" href="../../../topics/testing/tools/#django.test.TestCase" title="django.test.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> автоматически оборачивает каждый тест в транзакцию, вызывая <code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code> в <code class="docutils literal notranslate"><span class="pre">TestCase</span></code> даже вне блока <a class="reference internal" href="../../../topics/db/transactions/#django.db.transaction.atomic" title="django.db.transaction.atomic"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomic()</span></code></a> (возможно, неожиданно) пройдет без вызова <code class="docutils literal notranslate"><span class="pre">TransactionManagementError</span></code>. Для правильного тестирования <code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code> вы должны использовать <a class="reference internal" href="../../../topics/testing/tools/#django.test.TransactionTestCase" title="django.test.TransactionTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransactionTestCase</span></code></a>.</p>
</div>
<div class="admonition-certain-expressions-may-not-be-supported admonition">
<p class="first admonition-title">Некоторые выражения могут не поддерживаться</p>
<p class="last">PostgreSQL не поддерживает <code class="docutils literal notranslate"><span class="pre">select_for_update()</span></code> с выражениями <a class="reference internal" href="../expressions/#django.db.models.expressions.Window" title="django.db.models.expressions.Window"><code class="xref py py-class docutils literal notranslate"><span class="pre">Window</span></code></a>.</p>
</div>
</div>
<div class="section" id="s-raw">
<span id="raw"></span><h4><code class="docutils literal notranslate"><span class="pre">raw()</span></code><a class="headerlink" href="#raw" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.raw">
<code class="descname">raw</code>(<em><span class="n">raw_query</span></em>, <em><span class="n">params</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">translations</span><span class="o">=</span><span class="default_value">None</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.raw" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Принимает необработанный SQL-запрос, выполняет его и возвращает экземпляр <code class="docutils literal notranslate"><span class="pre">django.db.models.query.RawQuerySet</span></code>. Этот экземпляр <code class="docutils literal notranslate"><span class="pre">RawQuerySet</span></code> может быть повторен, как обычный <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, для предоставления экземпляров объекта.</p>
<p>Смотрите <a class="reference internal" href="../../../topics/db/sql/"><span class="doc">Выполнение необработанных SQL-запросов</span></a> для получения дополнительной информации.</p>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">raw()</span></code> всегда запускает новый запрос и не учитывает предыдущую фильтрацию. Как таковой, он обычно должен вызываться из <code class="docutils literal notranslate"><span class="pre">Manager</span></code> или из свежего <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="s-operators-that-return-new-querysets">
<span id="operators-that-return-new-querysets"></span><h3>Операторы, которые возвращают новый <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code><a class="headerlink" href="#operators-that-return-new-querysets" title="Ссылка на этот заголовок">¶</a></h3>
<p>Комбинированные наборы запросов должны использовать одну и ту же модель.</p>
<div class="section" id="s-and">
<span id="and"></span><h4>AND (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>)<a class="headerlink" href="#and" title="Ссылка на этот заголовок">¶</a></h4>
<p>Объединяет два <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>’а, используя оператор SQL <code class="docutils literal notranslate"><span class="pre">AND</span></code>.</p>
<p>Следующее эквивалентно:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Model</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Model</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Model</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">django.db.models</span> <span class="k">import</span> <span class="n">Q</span>
<span class="n">Model</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Q</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">x</span><span class="o">=</span><span class="mi">1</span> <span class="k">AND</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="s-or">
<span id="or"></span><h4>OR (<code class="docutils literal notranslate"><span class="pre">|</span></code>)<a class="headerlink" href="#or" title="Ссылка на этот заголовок">¶</a></h4>
<p>Объединяет два <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>’а, используя оператор SQL <code class="docutils literal notranslate"><span class="pre">OR</span></code>.</p>
<p>Следующее эквивалентно:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Model</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Model</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">django.db.models</span> <span class="k">import</span> <span class="n">Q</span>
<span class="n">Model</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">x</span><span class="o">=</span><span class="mi">1</span> <span class="k">OR</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-methods-that-do-not-return-querysets">
<span id="methods-that-do-not-return-querysets"></span><h3>Методы, которые не возвращают <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code><a class="headerlink" href="#methods-that-do-not-return-querysets" title="Ссылка на этот заголовок">¶</a></h3>
<p>Следующие методы <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> выполняют <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> и возвращают что-то <em>отличное от</em> <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>.</p>
<p>Эти методы не используют кеш (смотрите <a class="reference internal" href="../../../topics/db/queries/#caching-and-querysets"><span class="std std-ref">Кэширование и QuerySet</span></a>). Скорее, они запрашивают базу данных каждый раз, когда их вызывают.</p>
<div class="section" id="s-get">
<span id="get"></span><h4><code class="docutils literal notranslate"><span class="pre">get()</span></code><a class="headerlink" href="#get" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.get">
<code class="descname">get</code>(<em><span class="o">**</span><span class="n">kwargs</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.get" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает объект, соответствующий заданным параметрам поиска, который должен быть в формате, описанном в <a class="reference internal" href="#id4">Поиск по полям</a>. Вы должны использовать поиски, которые гарантированно уникальны, такие как первичный ключ или поля в ограничении уникальности. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">blog</span><span class="p">,</span> <span class="n">entry_number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Если вы ожидаете, что набор запросов уже вернет одну строку, вы можете использовать <code class="docutils literal notranslate"><span class="pre">get()</span></code> без каких-либо аргументов, чтобы вернуть объект для этой строки:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
<p>Если <code class="docutils literal notranslate"><span class="pre">get()</span></code> не находит никаких объектов, возникает исключение <a class="reference internal" href="../class/#django.db.models.Model.DoesNotExist" title="django.db.models.Model.DoesNotExist"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Model.DoesNotExist</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=-</span><span class="mi">999</span><span class="p">)</span> <span class="c"># raises Entry.DoesNotExist</span>
</pre></div>
</div>
<p>Если <code class="docutils literal notranslate"><span class="pre">get()</span></code> находит более одного объекта, он вызывает исключение <a class="reference internal" href="../class/#django.db.models.Model.MultipleObjectsReturned" title="django.db.models.Model.MultipleObjectsReturned"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Model.MultipleObjectsReturned</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;A Duplicated Name&#39;</span><span class="p">)</span> <span class="c"># raises Entry.MultipleObjectsReturned</span>
</pre></div>
</div>
<p>Оба эти класса исключений являются атрибутами класса модели и специфичны для этой модели. Если вы хотите обрабатывать такие исключения из нескольких вызовов <code class="docutils literal notranslate"><span class="pre">get()</span></code> для разных моделей, вы можете использовать их общие базовые классы. Например, вы можете использовать <a class="reference internal" href="../../exceptions/#django.core.exceptions.ObjectDoesNotExist" title="django.core.exceptions.ObjectDoesNotExist"><code class="xref py py-exc docutils literal notranslate"><span class="pre">django.core.exceptions.ObjectDoesNotExist</span></code></a> для обработки исключений <a class="reference internal" href="../class/#django.db.models.Model.DoesNotExist" title="django.db.models.Model.DoesNotExist"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DoesNotExist</span></code></a> из нескольких моделей:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.core.exceptions</span> <span class="k">import</span> <span class="n">ObjectDoesNotExist</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">blog</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">blog</span><span class="p">,</span> <span class="n">entry_number</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">except</span> <span class="n">ObjectDoesNotExist</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Either the blog or entry doesn&#39;t exist.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="s-create">
<span id="create"></span><h4><code class="docutils literal notranslate"><span class="pre">create()</span></code><a class="headerlink" href="#create" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.create">
<code class="descname">create</code>(<em><span class="o">**</span><span class="n">kwargs</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.create" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Удобный метод для создания объекта и сохранения всего за один шаг. Таким образом:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s">&quot;Bruce&quot;</span><span class="p">,</span> <span class="n">last_name</span><span class="o">=</span><span class="s">&quot;Springsteen&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>и:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s">&quot;Bruce&quot;</span><span class="p">,</span> <span class="n">last_name</span><span class="o">=</span><span class="s">&quot;Springsteen&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">force_insert</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
</pre></div>
</div>
<p>эквивалентны.</p>
<p>Параметр <a class="reference internal" href="../instances/#ref-models-force-insert"><span class="std std-ref">force_insert</span></a> задокументирован в другом месте, но все это означает, что новый объект всегда будет создаваться. Обычно вам не нужно беспокоиться об этом. Однако, если ваша модель содержит заданное вами значение первичного ключа вручную, и если это значение уже существует в базе данных, вызов <code class="docutils literal notranslate"><span class="pre">create()</span></code> завершится неудачно с <a class="reference internal" href="../../exceptions/#django.db.IntegrityError" title="django.db.IntegrityError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IntegrityError</span></code></a>, так как первичные ключи должны быть уникальными. Будьте готовы обработать исключение, если вы используете первичные ключи вручную.</p>
</div>
<div class="section" id="s-get-or-create">
<span id="get-or-create"></span><h4><code class="docutils literal notranslate"><span class="pre">get_or_create()</span></code><a class="headerlink" href="#get-or-create" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.get_or_create">
<code class="descname">get_or_create</code>(<em><span class="n">defaults</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.get_or_create" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Удобный метод для поиска объекта с указанным <code class="docutils literal notranslate"><span class="pre">kwargs</span></code> (может быть пустым, если в вашей модели есть значения по умолчанию для всех полей), создавая его при необходимости.</p>
<p>Возвращает кортеж <code class="docutils literal notranslate"><span class="pre">(object,</span> <span class="pre">created)</span></code>, где <code class="docutils literal notranslate"><span class="pre">object</span></code> - извлеченный или созданный объект, а <code class="docutils literal notranslate"><span class="pre">created</span></code> - логическое значение, указывающее, был ли создан новый объект.</p>
<p>Это предназначено для предотвращения создания дублирующихся объектов, когда запросы выполняются параллельно, и в качестве сокращения для упрощенного кода. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s">&#39;John&#39;</span><span class="p">,</span> <span class="n">last_name</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
<span class="k">except</span> <span class="n">Person</span><span class="o">.</span><span class="n">DoesNotExist</span><span class="p">:</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s">&#39;John&#39;</span><span class="p">,</span> <span class="n">last_name</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">,</span> <span class="n">birthday</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">1940</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>Здесь, при одновременных запросах, могут быть сделаны многочисленные попытки сохранить <code class="docutils literal notranslate"><span class="pre">Person</span></code> с одинаковыми параметрами. Чтобы избежать этого состояния гонки, приведенный выше пример можно переписать с помощью <code class="docutils literal notranslate"><span class="pre">get_or_create()</span></code>, например так:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">obj</span><span class="p">,</span> <span class="n">created</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get_or_create</span><span class="p">(</span>
    <span class="n">first_name</span><span class="o">=</span><span class="s">&#39;John&#39;</span><span class="p">,</span>
    <span class="n">last_name</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">,</span>
    <span class="n">defaults</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;birthday&#39;</span><span class="p">:</span> <span class="n">date</span><span class="p">(</span><span class="mi">1940</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">)},</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Любые ключевые аргументы, передаваемые в <code class="docutils literal notranslate"><span class="pre">get_or_create()</span></code> - <em>за исключением</em> необязательного аргумента, называемого <code class="docutils literal notranslate"><span class="pre">defaults</span></code> - будут использоваться в вызове <a class="reference internal" href="#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>. Если объект найден, <code class="docutils literal notranslate"><span class="pre">get_or_create()</span></code> возвращает кортеж этого объекта и <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p class="last">Этот метод является атомарным, предполагая, что база данных обеспечивает уникальность ключевых аргументов (смотрите <a class="reference internal" href="../fields/#django.db.models.Field.unique" title="django.db.models.Field.unique"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unique</span></code></a> или <a class="reference internal" href="../options/#django.db.models.Options.unique_together" title="django.db.models.Options.unique_together"><code class="xref py py-attr docutils literal notranslate"><span class="pre">unique_together</span></code></a>). Если поля, используемые в аргументах ключевого слова, не имеют ограничения уникальности, одновременные вызовы этого метода могут привести к вставке нескольких строк с одинаковыми параметрами.</p>
</div>
<p>Вы можете указать более сложные условия для извлеченного объекта, связав <code class="docutils literal notranslate"><span class="pre">get_or_create()</span></code> с <code class="docutils literal notranslate"><span class="pre">filter()</span></code> и используя <a class="reference internal" href="#django.db.models.Q" title="django.db.models.Q"><code class="xref py py-class docutils literal notranslate"><span class="pre">Q</span> <span class="pre">objects</span></code></a>. Например, чтобы получить Роберта или Боба Марли, если таковой существует, и создать последний в противном случае:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="k">import</span> <span class="n">Q</span>

<span class="n">obj</span><span class="p">,</span> <span class="n">created</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s">&#39;Bob&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s">&#39;Robert&#39;</span><span class="p">),</span>
<span class="p">)</span><span class="o">.</span><span class="n">get_or_create</span><span class="p">(</span><span class="n">last_name</span><span class="o">=</span><span class="s">&#39;Marley&#39;</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;first_name&#39;</span><span class="p">:</span> <span class="s">&#39;Bob&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>Если найдено несколько объектов, <code class="docutils literal notranslate"><span class="pre">get_or_create()</span></code> вызовет <a class="reference internal" href="../../exceptions/#django.core.exceptions.MultipleObjectsReturned" title="django.core.exceptions.MultipleObjectsReturned"><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultipleObjectsReturned</span></code></a>. Если объект <em>не</em> найден, <code class="docutils literal notranslate"><span class="pre">get_or_create()</span></code> создаст и сохранит новый объект, возвращая кортеж из нового объекта и <code class="docutils literal notranslate"><span class="pre">True</span></code>. Новый объект будет создан примерно согласно этому алгоритму:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s">&#39;__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">}</span>
<span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">()</span> <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">else</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
<span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
<span class="n">obj</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>По-английски это означает, что начинать нужно с любого не ключевого аргумента <code class="docutils literal notranslate"><span class="pre">'defaults'</span></code>, который не содержит двойного подчеркивания (что указывает на неточный поиск). Затем добавьте содержимое <code class="docutils literal notranslate"><span class="pre">defaults</span></code>, переопределив любые ключи, если необходимо, и используйте результат в качестве аргументов ключевого слова для класса модели. Если в <code class="docutils literal notranslate"><span class="pre">defaults</span></code> есть какие-либо вызываемые элементы, выполните их. Как уже упоминалось выше, это упрощение алгоритма, который используется, но он содержит все соответствующие детали. Внутренняя реализация имеет больше проверок ошибок, чем эта, и обрабатывает некоторые дополнительные граничные условия; если вам интересно, прочитайте код.</p>
<p>Если у вас есть поле с именем <code class="docutils literal notranslate"><span class="pre">defaults</span></code> и вы хотите использовать его для точного поиска в <code class="docutils literal notranslate"><span class="pre">get_or_create()</span></code>, просто используйте <code class="docutils literal notranslate"><span class="pre">'defaults__exact'</span></code>, например, так:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Foo</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get_or_create</span><span class="p">(</span><span class="n">defaults__exact</span><span class="o">=</span><span class="s">&#39;bar&#39;</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;defaults&#39;</span><span class="p">:</span> <span class="s">&#39;baz&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>Метод <code class="docutils literal notranslate"><span class="pre">get_or_create()</span></code> имеет схожее поведение ошибки с <a class="reference internal" href="#django.db.models.query.QuerySet.create" title="django.db.models.query.QuerySet.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create()</span></code></a>, когда вы используете указанные вручную первичные ключи. Если объект должен быть создан, а ключ уже существует в базе данных, будет вызвано <a class="reference internal" href="../../exceptions/#django.db.IntegrityError" title="django.db.IntegrityError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IntegrityError</span></code></a>.</p>
<p>Наконец, слово об использовании <code class="docutils literal notranslate"><span class="pre">get_or_create()</span></code> в представлениях Django. Обязательно используйте его только в запросах <code class="docutils literal notranslate"><span class="pre">POST</span></code>, если у вас нет веских причин не делать этого. Запросы <code class="docutils literal notranslate"><span class="pre">GET</span></code> не должны влиять на данные. Вместо этого используйте <code class="docutils literal notranslate"><span class="pre">POST</span></code> всякий раз, когда запрос страницы оказывает побочный эффект на ваши данные. Для получения дополнительной информации смотрите <span class="target" id="index-6"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc7231.html#section-4.2.1"><strong>Безопасные методы</strong></a> в спецификации HTTP.</p>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p>Вы можете использовать <code class="docutils literal notranslate"><span class="pre">get_or_create()</span></code> через <a class="reference internal" href="../fields/#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code class="xref py py-class docutils literal notranslate"><span class="pre">ManyToManyField</span></code></a> атрибуты и обратные отношения. В этом случае вы будете ограничивать запросы в контексте этого отношения. Это может привести к некоторым проблемам с целостностью, если вы не используете его постоянно.</p>
<p>Имея следующие модели:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Chapter</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Book</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">256</span><span class="p">)</span>
    <span class="n">chapters</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Chapter</span><span class="p">)</span>
</pre></div>
</div>
<p>Вы можете использовать <code class="docutils literal notranslate"><span class="pre">get_or_create()</span></code> через поле глав книги, но оно извлекается только внутри контекста этой книги:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">book</span> <span class="o">=</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s">&quot;Ulysses&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">book</span><span class="o">.</span><span class="n">chapters</span><span class="o">.</span><span class="n">get_or_create</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s">&quot;Telemachus&quot;</span><span class="p">)</span>
<span class="go">(&lt;Chapter: Telemachus&gt;, True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">book</span><span class="o">.</span><span class="n">chapters</span><span class="o">.</span><span class="n">get_or_create</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s">&quot;Telemachus&quot;</span><span class="p">)</span>
<span class="go">(&lt;Chapter: Telemachus&gt;, False)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Chapter</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s">&quot;Chapter 1&quot;</span><span class="p">)</span>
<span class="go">&lt;Chapter: Chapter 1&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">book</span><span class="o">.</span><span class="n">chapters</span><span class="o">.</span><span class="n">get_or_create</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s">&quot;Chapter 1&quot;</span><span class="p">)</span>
<span class="go"># Raises IntegrityError</span>
</pre></div>
</div>
<p class="last">Это происходит потому, что он пытается получить или создать «Главу 1» через книгу «Улисс», но не может сделать ни одну из них: отношение не может извлечь эту главу, потому что оно не связано с этой книгой, но он также не может создать его, потому что поле <code class="docutils literal notranslate"><span class="pre">title</span></code> должно быть уникальным.</p>
</div>
</div>
<div class="section" id="s-update-or-create">
<span id="update-or-create"></span><h4><code class="docutils literal notranslate"><span class="pre">update_or_create()</span></code><a class="headerlink" href="#update-or-create" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.update_or_create">
<code class="descname">update_or_create</code>(<em><span class="n">defaults</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.update_or_create" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Удобный метод для обновления объекта с указанным <code class="docutils literal notranslate"><span class="pre">kwargs</span></code>, создания нового при необходимости. <code class="docutils literal notranslate"><span class="pre">defaults</span></code> - это словарь пар (поле, значение), используемых для обновления объекта. Значения в <code class="docutils literal notranslate"><span class="pre">defaults</span></code> могут быть вызываемыми.</p>
<p>Возвращает кортеж <code class="docutils literal notranslate"><span class="pre">(object,</span> <span class="pre">created)</span></code>, где <code class="docutils literal notranslate"><span class="pre">object</span></code> является созданным или обновленным объектом, а <code class="docutils literal notranslate"><span class="pre">created</span></code> является логическим значением, указывающим, был ли создан новый объект.</p>
<p>Метод <code class="docutils literal notranslate"><span class="pre">update_or_create</span></code> пытается извлечь объект из базы данных на основе заданного <code class="docutils literal notranslate"><span class="pre">kwargs</span></code>. Если совпадение найдено, оно обновляет поля, переданные в словаре <code class="docutils literal notranslate"><span class="pre">defaults</span></code>.</p>
<p>Это просто сокращение для упрощенного кода. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;first_name&#39;</span><span class="p">:</span> <span class="s">&#39;Bob&#39;</span><span class="p">}</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="s">&#39;John&#39;</span><span class="p">,</span> <span class="n">last_name</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="k">except</span> <span class="n">Person</span><span class="o">.</span><span class="n">DoesNotExist</span><span class="p">:</span>
    <span class="n">new_values</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;first_name&#39;</span><span class="p">:</span> <span class="s">&#39;John&#39;</span><span class="p">,</span> <span class="s">&#39;last_name&#39;</span><span class="p">:</span> <span class="s">&#39;Lennon&#39;</span><span class="p">}</span>
    <span class="n">new_values</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">defaults</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">Person</span><span class="p">(</span><span class="o">**</span><span class="n">new_values</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>Эта модель становится довольно громоздкой, так как количество полей в модели увеличивается. Приведенный выше пример можно переписать с помощью <code class="docutils literal notranslate"><span class="pre">update_or_create()</span></code>, например так:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">obj</span><span class="p">,</span> <span class="n">created</span> <span class="o">=</span> <span class="n">Person</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">update_or_create</span><span class="p">(</span>
    <span class="n">first_name</span><span class="o">=</span><span class="s">&#39;John&#39;</span><span class="p">,</span> <span class="n">last_name</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">,</span>
    <span class="n">defaults</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;first_name&#39;</span><span class="p">:</span> <span class="s">&#39;Bob&#39;</span><span class="p">},</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Для подробного описания того, как разрешаются имена, передаваемые в <code class="docutils literal notranslate"><span class="pre">kwargs</span></code>, смотрите <a class="reference internal" href="#django.db.models.query.QuerySet.get_or_create" title="django.db.models.query.QuerySet.get_or_create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_or_create()</span></code></a>.</p>
<p>Как описано выше в <a class="reference internal" href="#django.db.models.query.QuerySet.get_or_create" title="django.db.models.query.QuerySet.get_or_create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_or_create()</span></code></a>, этот метод подвержен гоночному состоянию, которое может привести к одновременной вставке нескольких строк, если уникальность не обеспечивается на уровне базы данных.</p>
<p>Также как <a class="reference internal" href="#django.db.models.query.QuerySet.get_or_create" title="django.db.models.query.QuerySet.get_or_create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_or_create()</span></code></a> и <a class="reference internal" href="#django.db.models.query.QuerySet.create" title="django.db.models.query.QuerySet.create"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create()</span></code></a>, если вы используете указанные вручную первичные ключи, и объект должен быть создан, но ключ уже существует в базе данных, то это вызовет <a class="reference internal" href="../../exceptions/#django.db.IntegrityError" title="django.db.IntegrityError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IntegrityError</span></code></a>.</p>
</div>
<div class="section" id="s-bulk-create">
<span id="bulk-create"></span><h4><code class="docutils literal notranslate"><span class="pre">bulk_create()</span></code><a class="headerlink" href="#bulk-create" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.bulk_create">
<code class="descname">bulk_create</code>(<em><span class="n">objs</span></em>, <em><span class="n">batch_size</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">ignore_conflicts</span><span class="o">=</span><span class="default_value">False</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.bulk_create" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Этот метод эффективно вставляет предоставленный список объектов в базу данных (как правило, только 1 запрос, независимо от того, сколько объектов существует):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">bulk_create</span><span class="p">([</span>
<span class="gp">... </span>    <span class="n">Entry</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">&#39;This is a test&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Entry</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">&#39;This is only a test&#39;</span><span class="p">),</span>
<span class="gp">... </span><span class="p">])</span>
</pre></div>
</div>
<p>Это имеет ряд предостережений, хотя:</p>
<ul>
<li><p class="first">Метод <code class="docutils literal notranslate"><span class="pre">save()</span></code> модели вызываться не будет, а сигналы <code class="docutils literal notranslate"><span class="pre">pre_save</span></code> и <code class="docutils literal notranslate"><span class="pre">post_save</span></code> не будут отправлены.</p>
</li>
<li><p class="first">Он не работает с дочерними моделями в сценарии наследования нескольких таблиц.</p>
</li>
<li><p class="first">Если первичным ключом модели является <a class="reference internal" href="../fields/#django.db.models.AutoField" title="django.db.models.AutoField"><code class="xref py py-class docutils literal notranslate"><span class="pre">AutoField</span></code></a>, атрибут первичного ключа можно получить только в определенных базах данных (в настоящее время PostgreSQL и MariaDB 10.5+). На других базах данных он не будет установлен.</p>
</li>
<li><p class="first">Это не работает с отношениями «многие ко многим».</p>
</li>
<li><p class="first">Он бросает <code class="docutils literal notranslate"><span class="pre">objs</span></code> в список, который полностью выполняет <code class="docutils literal notranslate"><span class="pre">objs</span></code>, если это генератор. Приведение позволяет проверять все объекты, так что любые объекты с вручную установленным первичным ключом могут быть вставлены первыми. Если вы хотите вставить объекты в пакет без одновременной оценки всего генератора, вы можете использовать эту технику, если у объектов нет установленных первичных ключей вручную:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">islice</span>

<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">objs</span> <span class="o">=</span> <span class="p">(</span><span class="n">Entry</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">&#39;Test %s&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>
<span class="k">while</span> <span class="k">True</span><span class="p">:</span>
    <span class="n">batch</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">objs</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">batch</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">bulk_create</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>Параметр <code class="docutils literal notranslate"><span class="pre">batch_size</span></code> контролирует, сколько объектов создается в одном запросе. По умолчанию все объекты создаются в одном пакете, за исключением SQLite, где по умолчанию используется не более 999 переменных на запрос.</p>
<p>В базах данных, которые это поддерживают (все, кроме Oracle), установка параметра <code class="docutils literal notranslate"><span class="pre">ignore_conflicts</span></code> в <code class="docutils literal notranslate"><span class="pre">True</span></code> указывает базе данных игнорировать сбой при вставке любых строк, которые не соответствуют ограничениям, таким как дублирующиеся уникальные значения. Включение этого параметра отключает установку первичного ключа для каждого экземпляра модели (если база данных обычно его поддерживает).</p>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p class="last">В MySQL и MariaDB установка параметра <code class="docutils literal notranslate"><span class="pre">ignore_conflicts</span></code> на <code class="docutils literal notranslate"><span class="pre">True</span></code> превращает определенные типы ошибок, кроме повторяющегося ключа, в предупреждения. Даже в строгом режиме. Например: недопустимые значения или нарушения, не допускающие значения NULL. Дополнительную информацию смотрите в <span class="xref std std-ref">документации MySQL</span> и <span class="xref std std-ref">документации MariaDB</span>.</p>
</div>
<p>Возвращает <code class="docutils literal notranslate"><span class="pre">objs</span></code>, приведенный к списку, в том же порядке, что и предоставленный.</p>
<div class="versionchanged">
<span class="title">Changed in Django 3.1:</span> <p>Добавлена поддержка извлечения атрибутов первичного ключа на MariaDB 10.5+.</p>
</div>
</div>
<div class="section" id="s-bulk-update">
<span id="bulk-update"></span><h4><code class="docutils literal notranslate"><span class="pre">bulk_update()</span></code><a class="headerlink" href="#bulk-update" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.bulk_update">
<code class="descname">bulk_update</code>(<em><span class="n">objs</span></em>, <em><span class="n">fields</span></em>, <em><span class="n">batch_size</span><span class="o">=</span><span class="default_value">None</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.bulk_update" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Этот метод эффективно обновляет данные поля в предоставленных экземплярах модели, обычно одним запросом:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">objs</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>   <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">&#39;Entry 1&#39;</span><span class="p">),</span>
<span class="gp">... </span>   <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">&#39;Entry 2&#39;</span><span class="p">),</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">headline</span> <span class="o">=</span> <span class="s">&#39;This is entry 1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">objs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">headline</span> <span class="o">=</span> <span class="s">&#39;This is entry 2&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">bulk_update</span><span class="p">(</span><span class="n">objs</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;headline&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p><a class="reference internal" href="#django.db.models.query.QuerySet.update" title="django.db.models.query.QuerySet.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">QuerySet.update()</span></code></a> используется для сохранения изменений, поэтому это более эффективно, чем перебирать список моделей и вызывать <code class="docutils literal notranslate"><span class="pre">save()</span></code> для каждой из них, но имеет несколько предостережений:</p>
<ul class="simple">
<li>Вы не можете обновить первичный ключ модели.</li>
<li>Метод <code class="docutils literal notranslate"><span class="pre">save()</span></code> каждой модели не вызывается, и сигналы <a class="reference internal" href="../../signals/#django.db.models.signals.pre_save" title="django.db.models.signals.pre_save"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pre_save</span></code></a> и <a class="reference internal" href="../../signals/#django.db.models.signals.post_save" title="django.db.models.signals.post_save"><code class="xref py py-attr docutils literal notranslate"><span class="pre">post_save</span></code></a> не отправлено.</li>
<li>При обновлении большого количества столбцов в большом количестве строк сгенерированный SQL может быть очень большим. Избегайте этого, указав подходящий <code class="docutils literal notranslate"><span class="pre">batch_size</span></code>.</li>
<li>Обновление полей, определенных в предках наследования нескольких таблиц, повлечет за собой дополнительный запрос для предка.</li>
<li>Если отдельный пакет содержит дубликаты, только первый экземпляр в этом пакете приведет к обновлению.</li>
</ul>
<p>Параметр <code class="docutils literal notranslate"><span class="pre">batch_size</span></code> определяет, сколько объектов сохраняется в одном запросе. По умолчанию обновляются все объекты в одном пакете, кроме SQLite и Oracle, которые имеют ограничения по количеству переменных, используемых в запросе.</p>
</div>
<div class="section" id="s-count">
<span id="count"></span><h4><code class="docutils literal notranslate"><span class="pre">count()</span></code><a class="headerlink" href="#count" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.count">
<code class="descname">count</code>()<a class="headerlink" href="#django.db.models.query.QuerySet.count" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает целое число, представляющее количество объектов в базе данных, соответствующих <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="c"># Returns the total number of entries in the database.</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

<span class="c"># Returns the number of entries whose headline contains &#39;Lennon&#39;</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
<p>Вызов <code class="docutils literal notranslate"><span class="pre">count()</span></code> выполняет <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">COUNT</span> <span class="pre">(*)</span></code> за кулисами, поэтому вы всегда должны использовать <code class="docutils literal notranslate"><span class="pre">count()</span></code> вместо того, чтобы загружать всю запись в объекты Python и вызывать <code class="docutils literal notranslate"><span class="pre">len()</span></code> на результат (если вам все равно не нужно загружать объекты в память, в этом случае <code class="docutils literal notranslate"><span class="pre">len()</span></code> будет быстрее).</p>
<p>Обратите внимание, что если вы хотите подсчитать количество элементов в <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> и также извлекаете из него экземпляры модели (например, путем итерации по нему), возможно, более эффективно использовать <code class="docutils literal notranslate"><span class="pre">len(queryset)</span></code>, который не вызывает дополнительный запрос к базе данных, как <code class="docutils literal notranslate"><span class="pre">count()</span></code>.</p>
</div>
<div class="section" id="s-in-bulk">
<span id="in-bulk"></span><h4><code class="docutils literal notranslate"><span class="pre">in_bulk()</span></code><a class="headerlink" href="#in-bulk" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.in_bulk">
<code class="descname">in_bulk</code>(<em><span class="n">id_list</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="o">*</span></em>, <em><span class="n">field_name</span><span class="o">=</span><span class="default_value">'pk'</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.in_bulk" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Принимает список значений поля (<code class="docutils literal notranslate"><span class="pre">id_list</span></code>) и <code class="docutils literal notranslate"><span class="pre">field_name</span></code> для этих значений и возвращает словарь, отображающий каждое значение на экземпляр объекта с данным значением поля. Если <code class="docutils literal notranslate"><span class="pre">id_list</span></code> не предоставлен, возвращаются все объекты в наборе запросов. <code class="docutils literal notranslate"><span class="pre">field_name</span></code> должно быть уникальным полем, по умолчанию используется первичный ключ.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">in_bulk</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">{1: &lt;Blog: Beatles Blog&gt;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">in_bulk</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">{1: &lt;Blog: Beatles Blog&gt;, 2: &lt;Blog: Cheddar Talk&gt;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">in_bulk</span><span class="p">([])</span>
<span class="go">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">in_bulk</span><span class="p">()</span>
<span class="go">{1: &lt;Blog: Beatles Blog&gt;, 2: &lt;Blog: Cheddar Talk&gt;, 3: &lt;Blog: Django Weblog&gt;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">in_bulk</span><span class="p">([</span><span class="s">&#39;beatles_blog&#39;</span><span class="p">],</span> <span class="n">field_name</span><span class="o">=</span><span class="s">&#39;slug&#39;</span><span class="p">)</span>
<span class="go">{&#39;beatles_blog&#39;: &lt;Blog: Beatles Blog&gt;}</span>
</pre></div>
</div>
<p>Если вы передадите <code class="docutils literal notranslate"><span class="pre">in_bulk()</span></code> пустой список, вы получите пустой словарь.</p>
</div>
<div class="section" id="s-iterator">
<span id="iterator"></span><h4><code class="docutils literal notranslate"><span class="pre">iterator()</span></code><a class="headerlink" href="#iterator" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.iterator">
<code class="descname">iterator</code>(<em><span class="n">chunk_size</span><span class="o">=</span><span class="default_value">2000</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.iterator" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Вычисляет <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> (выполняя запрос) и возвращает итератор (смотрите <span class="target" id="index-7"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0234"><strong>PEP 234</strong></a>) по результатам. <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> обычно кэширует свои результаты внутренне, так что повторные вычисления не приводят к дополнительным запросам. Напротив, <code class="docutils literal notranslate"><span class="pre">iterator()</span></code> будет читать результаты напрямую, без какого-либо кэширования на уровне <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> (внутренне, итератор по умолчанию вызывает <code class="docutils literal notranslate"><span class="pre">iterator()</span></code> и кэширует возвращаемое значение). Для <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, который возвращает большое количество объектов, к которым вам нужно получить доступ только один раз, это может привести к повышению производительности и значительному сокращению памяти.</p>
<p>Обратите внимание, что использование <code class="docutils literal notranslate"><span class="pre">iterator()</span></code> на <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, который уже был оценен, заставит его вычислять снова, повторяя запрос.</p>
<p>Кроме того, использование <code class="docutils literal notranslate"><span class="pre">iterator()</span></code> приводит к игнорированию предыдущих вызовов <code class="docutils literal notranslate"><span class="pre">prefetch_related()</span></code>, поскольку эти две оптимизации не имеют смысла вместе.</p>
<p>В зависимости от серверной части базы данных результаты запроса будут загружаться одновременно или передаваться из базы данных с использованием серверных курсоров.</p>
<div class="section" id="s-with-server-side-cursors">
<span id="with-server-side-cursors"></span><h5>С серверными курсорами<a class="headerlink" href="#with-server-side-cursors" title="Ссылка на этот заголовок">¶</a></h5>
<p>Oracle и <a class="reference internal" href="../../databases/#postgresql-server-side-cursors"><span class="std std-ref">PostgreSQL</span></a> используют серверные курсоры для потоковой передачи результатов из базы данных без загрузки всего набора результатов в память.</p>
<p>Драйвер базы данных Oracle всегда использует серверные курсоры.</p>
<p>В случае серверных курсоров параметр <code class="docutils literal notranslate"><span class="pre">chunk_size</span></code> указывает количество результатов, которые необходимо кэшировать на уровне драйвера базы данных. Выборка больших кусков уменьшает количество циклов между драйвером базы данных и базой данных за счет памяти.</p>
<p>В PostgreSQL серверные курсоры будут использоваться, только если для параметра <a class="reference internal" href="../../settings/#std-setting-DATABASE-DISABLE_SERVER_SIDE_CURSORS"><code class="xref std std-setting docutils literal notranslate"><span class="pre">DISABLE_SERVER_SIDE_CURSORS</span></code></a> установлено значение <code class="docutils literal notranslate"><span class="pre">False</span></code>. Прочитайте <a class="reference internal" href="../../databases/#transaction-pooling-server-side-cursors"><span class="std std-ref">Объединение транзакций и курсоры на стороне сервера</span></a>, если вы используете пул соединений, настроенный в режиме пула транзакций. Когда серверные курсоры отключены, поведение аналогично базам данных, которые не поддерживают серверные курсоры.</p>
</div>
<div class="section" id="s-without-server-side-cursors">
<span id="without-server-side-cursors"></span><h5>Без серверных курсоров<a class="headerlink" href="#without-server-side-cursors" title="Ссылка на этот заголовок">¶</a></h5>
<p>MySQL не поддерживает потоковые результаты, поэтому драйвер базы данных Python загружает весь набор результатов в память. Затем результирующий набор преобразуется в объекты строк Python с помощью адаптера базы данных с помощью метода <code class="docutils literal notranslate"><span class="pre">fetchmany()</span></code>, определенного в <span class="target" id="index-8"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0249"><strong>PEP 249</strong></a>.</p>
<p>SQLite может получать результаты в пакетах, используя <code class="docutils literal notranslate"><span class="pre">fetchmany()</span></code>, но поскольку SQLite не обеспечивает изоляцию между запросами в соединении, будьте осторожны при записи в таблицу, для которой выполняется итерация. Смотрите <a class="reference internal" href="../../databases/#sqlite-isolation"><span class="std std-ref">Изоляция при использовании QuerySet.iterator()</span></a> для получения дополнительной информации.</p>
<p>Параметр <code class="docutils literal notranslate"><span class="pre">chunk_size</span></code> управляет размером пакетов, которые Django извлекает из драйвера базы данных. Большие пакеты уменьшают накладные расходы на связь с драйвером базы данных за счет небольшого увеличения потребления памяти.</p>
<p>Значение по умолчанию <code class="docutils literal notranslate"><span class="pre">chunk_size</span></code>, 2000, взято из вычисления в списке рассылки psycopg &lt;https://www.postgresql.org/message-id/4D2F2C71.8080805%40dndg.it&gt; _:</p>
<blockquote>
<div>Предполагая, что строки из 10-20 столбцов содержат смесь текстовых и числовых данных, 2000 будет собирать данные размером менее 100 КБ, что представляется хорошим компромиссом между количеством переданных строк и данными, отброшенными, если цикл завершается досрочно.</div></blockquote>
</div>
</div>
<div class="section" id="s-latest">
<span id="latest"></span><h4><code class="docutils literal notranslate"><span class="pre">latest()</span></code><a class="headerlink" href="#latest" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.latest">
<code class="descname">latest</code>(<em><span class="o">*</span><span class="n">fields</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.latest" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает последний объект в таблице на основе заданных полей.</p>
<p>Этот пример возвращает последний <code class="docutils literal notranslate"><span class="pre">Entry</span></code> в таблице, согласно полю <code class="docutils literal notranslate"><span class="pre">pub_date</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">latest</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Вы также можете выбрать последнюю версию на основе нескольких полей. Например, чтобы выбрать <code class="docutils literal notranslate"><span class="pre">Entry</span></code> с самым ранним <code class="docutils literal notranslate"><span class="pre">expire_date</span></code>, когда две записи имеют одинаковое <code class="docutils literal notranslate"><span class="pre">pub_date</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">latest</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">,</span> <span class="s">&#39;-expire_date&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Отрицательный знак в <code class="docutils literal notranslate"><span class="pre">'-expire_date'</span></code> означает сортировку <code class="docutils literal notranslate"><span class="pre">expire_date</span></code> в <em>обратном</em> порядке. Поскольку <code class="docutils literal notranslate"><span class="pre">latest()</span></code> получает последний результат, выбирается <code class="docutils literal notranslate"><span class="pre">Entry</span></code> с самым ранним <code class="docutils literal notranslate"><span class="pre">expire_date</span></code>.</p>
<p>Если ваша модель <a class="reference internal" href="../../../topics/db/models/#meta-options"><span class="std std-ref">Meta</span></a> указывает <a class="reference internal" href="../options/#django.db.models.Options.get_latest_by" title="django.db.models.Options.get_latest_by"><code class="xref py py-attr docutils literal notranslate"><span class="pre">get_latest_by</span></code></a>, вы можете опустить любые аргументы для <code class="docutils literal notranslate"><span class="pre">earliest()</span></code> или <code class="docutils literal notranslate"><span class="pre">latest()</span></code>. Поля, указанные в <a class="reference internal" href="../options/#django.db.models.Options.get_latest_by" title="django.db.models.Options.get_latest_by"><code class="xref py py-attr docutils literal notranslate"><span class="pre">get_latest_by</span></code></a>, будут использоваться по умолчанию.</p>
<p>Например <a class="reference internal" href="#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>, <code class="docutils literal notranslate"><span class="pre">earliest()</span></code> и <code class="docutils literal notranslate"><span class="pre">latest()</span></code> вызывают <a class="reference internal" href="../class/#django.db.models.Model.DoesNotExist" title="django.db.models.Model.DoesNotExist"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DoesNotExist</span></code></a>, если нет объекта с данными параметрами.</p>
<p>Обратите внимание, что <code class="docutils literal notranslate"><span class="pre">earliest()</span></code> и <code class="docutils literal notranslate"><span class="pre">latest()</span></code> существуют исключительно для удобства и читабельности.</p>
<div class="admonition-earliest-and-latest-may-return-instances-with-null-dates admonition">
<p class="first admonition-title"><code class="docutils literal notranslate"><span class="pre">earliest()</span></code> и <code class="docutils literal notranslate"><span class="pre">latest()</span></code> могут возвращать экземпляры с нулевыми датами.</p>
<p>Поскольку порядок делегирования в базе данных, результаты в полях, которые допускают нулевые значения, могут быть упорядочены по-разному, если вы используете разные базы данных. Например, PostgreSQL и MySQL сортируют нулевые значения, как будто они выше ненулевых значений, в то время как SQLite делает обратное.</p>
<p>Вы можете отфильтровать нулевые значения:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__isnull</span><span class="o">=</span><span class="k">False</span><span class="p">)</span><span class="o">.</span><span class="n">latest</span><span class="p">(</span><span class="s">&#39;pub_date&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-earliest">
<span id="earliest"></span><h4><code class="docutils literal notranslate"><span class="pre">earliest()</span></code><a class="headerlink" href="#earliest" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.earliest">
<code class="descname">earliest</code>(<em><span class="o">*</span><span class="n">fields</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.earliest" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Работает также как и <a class="reference internal" href="#django.db.models.query.QuerySet.latest" title="django.db.models.query.QuerySet.latest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">latest()</span></code></a> за исключением изменения направления.</p>
</div>
<div class="section" id="s-first">
<span id="first"></span><h4><code class="docutils literal notranslate"><span class="pre">first()</span></code><a class="headerlink" href="#first" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.first">
<code class="descname">first</code>()<a class="headerlink" href="#django.db.models.query.QuerySet.first" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает первый объект, соответствующий запросу, или <code class="docutils literal notranslate"><span class="pre">None</span></code>, если нет соответствующего объекта. Если <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> не имеет определенного порядка, то набор запросов автоматически упорядочивается по первичному ключу. Это может повлиять на результаты агрегации, как описано в <a class="reference internal" href="../../../topics/db/aggregation/#aggregation-ordering-interaction"><span class="std std-ref">Взаимодействие с сортировкой по умолчанию или order_by()</span></a>.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">Article</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;title&#39;</span><span class="p">,</span> <span class="s">&#39;pub_date&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
</pre></div>
</div>
<p>Обратите внимание, что <code class="docutils literal notranslate"><span class="pre">first()</span></code> является вспомогательным методом, следующий пример кода эквивалентен приведенному выше примеру:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Article</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;title&#39;</span><span class="p">,</span> <span class="s">&#39;pub_date&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="k">None</span>
</pre></div>
</div>
</div>
<div class="section" id="s-last">
<span id="last"></span><h4><code class="docutils literal notranslate"><span class="pre">last()</span></code><a class="headerlink" href="#last" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.last">
<code class="descname">last</code>()<a class="headerlink" href="#django.db.models.query.QuerySet.last" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Работает как <a class="reference internal" href="#django.db.models.query.QuerySet.first" title="django.db.models.query.QuerySet.first"><code class="xref py py-meth docutils literal notranslate"><span class="pre">first()</span></code></a>, но возвращает последний объект в наборе запросов.</p>
</div>
<div class="section" id="s-aggregate">
<span id="aggregate"></span><h4><code class="docutils literal notranslate"><span class="pre">aggregate()</span></code><a class="headerlink" href="#aggregate" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.aggregate">
<code class="descname">aggregate</code>(<em><span class="o">*</span><span class="n">args</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.aggregate" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает словарь агрегированных значений (средние, суммы и т.д.), рассчитанных по <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>. Каждый аргумент <code class="docutils literal notranslate"><span class="pre">aggregate()</span></code> указывает значение, которое будет включено в возвращаемый словарь.</p>
<p>Функции агрегации, предоставляемые Django, описаны в <a class="reference internal" href="#id5">Функции агрегации</a> ниже. Поскольку агрегаты также являются <a class="reference internal" href="../expressions/"><span class="doc">выражениями запросов</span></a>, вы можете комбинировать агрегаты с другими агрегатами или значениями для создания сложных агрегатов.</p>
<p>Агрегаты, указанные с использованием аргументов ключевого слова, будут использовать ключевое слово в качестве имени для аннотации. Для анонимных аргументов будет создано имя, основанное на имени агрегирующей функции и агрегируемого поля модели. Сложные агрегаты не могут использовать анонимные аргументы и должны указывать ключевое слово аргумент в качестве псевдонима.</p>
<p>Например, когда вы работаете с записями в блоге, вы можете узнать количество авторов, которые предоставили записи в блоге:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="k">import</span> <span class="n">Count</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">Count</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">))</span>
<span class="go">{&#39;entry__count&#39;: 16}</span>
</pre></div>
</div>
<p>Используя аргумент ключевого слова для указания функции агрегирования, вы можете контролировать имя возвращаемого значения агрегации:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">number_of_entries</span><span class="o">=</span><span class="n">Count</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">))</span>
<span class="go">{&#39;number_of_entries&#39;: 16}</span>
</pre></div>
</div>
<p>Подробное обсуждение агрегации смотрите в <a class="reference internal" href="../../../topics/db/aggregation/"><span class="doc">руководство по агрегации</span></a>.</p>
</div>
<div class="section" id="s-exists">
<span id="exists"></span><h4><code class="docutils literal notranslate"><span class="pre">exists()</span></code><a class="headerlink" href="#exists" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.exists">
<code class="descname">exists</code>()<a class="headerlink" href="#django.db.models.query.QuerySet.exists" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает <code class="docutils literal notranslate"><span class="pre">True</span></code>, если <a class="reference internal" href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> содержит какие-либо результаты, и <code class="docutils literal notranslate"><span class="pre">False</span></code>, если нет. Он пытается выполнить запрос самым простым и быстрым способом, но он <em>выполняет</em> почти тот же запрос, что и обычный <a class="reference internal" href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>.</p>
<p><a class="reference internal" href="#django.db.models.query.QuerySet.exists" title="django.db.models.query.QuerySet.exists"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exists()</span></code></a> полезен для поиска, относящегося как к членству объекта в <a class="reference internal" href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>, так и к существованию любых объектов в <a class="reference internal" href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>, особенно в контексте большой <a class="reference internal" href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>.</p>
<p>Наиболее эффективный метод определения, является ли модель с уникальным полем (например, <code class="docutils literal notranslate"><span class="pre">primary_key</span></code>) членом <a class="reference internal" href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>, это:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">entry</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">123</span><span class="p">)</span>
<span class="k">if</span> <span class="n">some_queryset</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="n">entry</span><span class="o">.</span><span class="n">pk</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Entry contained in queryset&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Который будет быстрее, чем следующий, который требует оценки и итерации по всему набору запросов:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">if</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">some_queryset</span><span class="p">:</span>
   <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Entry contained in QuerySet&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>И чтобы узнать, содержит ли набор запросов какие-либо элементы:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">if</span> <span class="n">some_queryset</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;There is at least one object in some_queryset&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Который будет быстрее, чем</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">if</span> <span class="n">some_queryset</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;There is at least one object in some_queryset&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>… но не в значительной степени (следовательно, для повышения эффективности требуется большой набор запросов).</p>
<p>Кроме того, если <code class="docutils literal notranslate"><span class="pre">some_queryset</span></code> еще не был проанализирован, но вы знаете, что это произойдет в какой-то момент, то использование <code class="docutils literal notranslate"><span class="pre">some_queryset.exists()</span></code> сделает более общую работу (один запрос для проверки существования плюс дополнительный для последующего извлечения результатов), а не просто <code class="docutils literal notranslate"><span class="pre">bool(some_queryset)</span></code>, который извлекает результаты и затем проверяет, были ли какие-либо возвращены.</p>
</div>
<div class="section" id="s-update">
<span id="update"></span><h4><code class="docutils literal notranslate"><span class="pre">update()</span></code><a class="headerlink" href="#update" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.update">
<code class="descname">update</code>(<em><span class="o">**</span><span class="n">kwargs</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.update" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Выполняет запрос на обновление SQL для указанных полей и возвращает количество совпадающих строк (которое может не совпадать с количеством обновленных строк, если некоторые строки уже имеют новое значение).</p>
<p>Например, чтобы отключить комментарии для всех записей блога, опубликованных в 2010 году, вы можете сделать это:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2010</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">comments_on</span><span class="o">=</span><span class="k">False</span><span class="p">)</span>
</pre></div>
</div>
<p>(Предполагается, что ваша модель <code class="docutils literal notranslate"><span class="pre">Entry</span></code> имеет поля <code class="docutils literal notranslate"><span class="pre">pub_date</span></code> и <code class="docutils literal notranslate"><span class="pre">comments_on</span></code>.)</p>
<p>Вы можете обновить несколько полей - нет ограничений на их количество. Например, здесь мы обновляем поля <code class="docutils literal notranslate"><span class="pre">comments_on</span></code> и <code class="docutils literal notranslate"><span class="pre">headline</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2010</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">comments_on</span><span class="o">=</span><span class="k">False</span><span class="p">,</span> <span class="n">headline</span><span class="o">=</span><span class="s">&#39;This is old&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Метод <code class="docutils literal notranslate"><span class="pre">update()</span></code> применяется мгновенно, и единственное ограничение на обновляемый <a class="reference internal" href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> заключается в том, что он может обновлять только столбцы в основной таблице модели, но не в связанных моделях. Вы не можете сделать так, например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">blog__name</span><span class="o">=</span><span class="s">&#39;foo&#39;</span><span class="p">)</span> <span class="c"># Won&#39;t work!</span>
</pre></div>
</div>
<p>Фильтрация на основе связанных полей все еще возможна, хотя:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">comments_on</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Вы не можете вызвать <code class="docutils literal notranslate"><span class="pre">update()</span></code> для <a class="reference internal" href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>, у которого был взят фрагмент или который больше не может быть отфильтрован.</p>
<p>Метод <code class="docutils literal notranslate"><span class="pre">update()</span></code> возвращает количество затронутых строк:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">comments_on</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
<span class="go">1</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">slug</span><span class="o">=</span><span class="s">&#39;nonexistent-slug&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">comments_on</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
<span class="go">0</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2010</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">comments_on</span><span class="o">=</span><span class="k">False</span><span class="p">)</span>
<span class="go">132</span>
</pre></div>
</div>
<p>Если вы просто обновляете запись и вам не нужно ничего делать с объектом модели, наиболее эффективным подходом является вызов <code class="docutils literal notranslate"><span class="pre">update()</span></code> вместо загрузки объекта модели в память. Например, вместо этого:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">e</span><span class="o">.</span><span class="n">comments_on</span> <span class="o">=</span> <span class="k">False</span>
<span class="n">e</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>…сделайте это:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">comments_on</span><span class="o">=</span><span class="k">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Использование <code class="docutils literal notranslate"><span class="pre">update()</span></code> также предотвращает состояние гонки, при котором что-то может измениться в вашей базе данных за короткий промежуток времени между загрузкой объекта и вызовом <code class="docutils literal notranslate"><span class="pre">save()</span></code>.</p>
<p>Наконец, следует понимать, что <code class="docutils literal notranslate"><span class="pre">update()</span></code> выполняет обновление на уровне SQL и, таким образом, не вызывает никаких методов <code class="docutils literal notranslate"><span class="pre">save()</span></code> в ваших моделях и не генерирует <a class="reference internal" href="../../signals/#django.db.models.signals.pre_save" title="django.db.models.signals.pre_save"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pre_save</span></code></a> или <a class="reference internal" href="../../signals/#django.db.models.signals.post_save" title="django.db.models.signals.post_save"><code class="xref py py-attr docutils literal notranslate"><span class="pre">post_save</span></code></a> (которые являются следствием вызова <a class="reference internal" href="../instances/#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Model.save()</span></code></a>). Если вы хотите обновить группу записей для модели, имеющей пользовательский метод <a class="reference internal" href="../instances/#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a>, выполните их в цикле и вызовите <a class="reference internal" href="../instances/#django.db.models.Model.save" title="django.db.models.Model.save"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a>, как тут:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2010</span><span class="p">):</span>
    <span class="n">e</span><span class="o">.</span><span class="n">comments_on</span> <span class="o">=</span> <span class="k">False</span>
    <span class="n">e</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="s-delete">
<span id="delete"></span><h4><code class="docutils literal notranslate"><span class="pre">delete()</span></code><a class="headerlink" href="#delete" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.delete">
<code class="descname">delete</code>()<a class="headerlink" href="#django.db.models.query.QuerySet.delete" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Выполняет запрос на удаление SQL для всех строк в <a class="reference internal" href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a> и возвращает количество удаленных объектов и словарь с количеством удалений на тип объекта.</p>
<p><code class="docutils literal notranslate"><span class="pre">delete()</span></code> применяется мгновенно. Вы не можете вызвать <code class="docutils literal notranslate"><span class="pre">delete()</span></code> для <a class="reference internal" href="#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuerySet</span></code></a>, у которого был взят фрагмент или который больше не может быть отфильтрован.</p>
<p>Например, чтобы удалить все записи в определенном блоге:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="go"># Delete all the entries belonging to this Blog.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
<span class="go">(4, {&#39;weblog.Entry&#39;: 2, &#39;weblog.Entry_authors&#39;: 2})</span>
</pre></div>
</div>
<p>По умолчанию класс Django <a class="reference internal" href="../fields/#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> эмулирует ограничение SQL <code class="docutils literal notranslate"><span class="pre">ON</span> <span class="pre">DELETE</span> <span class="pre">CASCADE</span></code> - другими словами, любые объекты с внешними ключами, указывающими на объекты, которые будут удалены, будут удалены вместе с ними. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">blogs</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="go"># This will delete all Blogs and all of their Entry objects.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blogs</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
<span class="go">(5, {&#39;weblog.Blog&#39;: 1, &#39;weblog.Entry&#39;: 2, &#39;weblog.Entry_authors&#39;: 2})</span>
</pre></div>
</div>
<p>Это каскадное поведение настраивается с помощью аргумента <a class="reference internal" href="../fields/#django.db.models.ForeignKey.on_delete" title="django.db.models.ForeignKey.on_delete"><code class="xref py py-attr docutils literal notranslate"><span class="pre">on_delete</span></code></a> для <a class="reference internal" href="../fields/#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a>.</p>
<p>Метод <code class="docutils literal notranslate"><span class="pre">delete()</span></code> выполняет массовое удаление и не вызывает никаких методов <code class="docutils literal notranslate"><span class="pre">delete()</span></code> в ваших моделях. Однако он генерирует сигналы <a class="reference internal" href="../../signals/#django.db.models.signals.pre_delete" title="django.db.models.signals.pre_delete"><code class="xref py py-data docutils literal notranslate"><span class="pre">pre_delete</span></code></a> и <a class="reference internal" href="../../signals/#django.db.models.signals.post_delete" title="django.db.models.signals.post_delete"><code class="xref py py-data docutils literal notranslate"><span class="pre">post_delete</span></code></a> для всех удаленных объектов (включая каскадные удаления).</p>
<p>Django должен извлекать объекты в память для отправки сигналов и обработки каскадов. Однако, если нет каскадов и нет сигналов, тогда Django может использовать ускоренный путь и удалять объекты без загрузки в память. Для больших удалений это может привести к значительному сокращению использования памяти. Количество выполненных запросов также может быть уменьшено.</p>
<p>Внешние ключи, для которых установлено <a class="reference internal" href="../fields/#django.db.models.ForeignKey.on_delete" title="django.db.models.ForeignKey.on_delete"><code class="xref py py-attr docutils literal notranslate"><span class="pre">on_delete</span></code></a> <code class="docutils literal notranslate"><span class="pre">DO_NOTHING</span></code>, не мешают использовать быстрый путь при удалении.</p>
<p>Обратите внимание, что запросы, сгенерированные при удалении объекта, являются деталями реализации, которые могут быть изменены.</p>
</div>
<div class="section" id="s-as-manager">
<span id="as-manager"></span><h4><code class="docutils literal notranslate"><span class="pre">as_manager()</span></code><a class="headerlink" href="#as-manager" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.as_manager">
<em class="property">classmethod </em><code class="descname">as_manager</code>()<a class="headerlink" href="#django.db.models.query.QuerySet.as_manager" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Метод класса, который возвращает экземпляр <a class="reference internal" href="../../../topics/db/managers/#django.db.models.Manager" title="django.db.models.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> с копией методов <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>. Смотрите <a class="reference internal" href="../../../topics/db/managers/#create-manager-with-queryset-methods"><span class="std std-ref">Создание менеджера с помощью методов QuerySet</span></a> для более подробной информации.</p>
</div>
<div class="section" id="s-explain">
<span id="explain"></span><h4><code class="docutils literal notranslate"><span class="pre">explain()</span></code><a class="headerlink" href="#explain" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py method">
<dt id="django.db.models.query.QuerySet.explain">
<code class="descname">explain</code>(<em><span class="n">format</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="o">**</span><span class="n">options</span></em>)<a class="headerlink" href="#django.db.models.query.QuerySet.explain" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Возвращает строку плана выполнения <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, в которой подробно описывается, как база данных будет выполнять запрос, включая любые индексы или объединения, которые будут использоваться. Знание этих деталей может помочь вам повысить производительность медленных запросов.</p>
<p>Например, при использовании PostgreSQL:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s">&#39;My Blog&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">explain</span><span class="p">())</span>
<span class="go">Seq Scan on blog  (cost=0.00..35.50 rows=10 width=12)</span>
<span class="go">  Filter: (title = &#39;My Blog&#39;::bpchar)</span>
</pre></div>
</div>
<p>Вывод значительно различается между базами данных.</p>
<p><code class="docutils literal notranslate"><span class="pre">explain()</span></code> поддерживается всеми встроенными базами данных базы данных, кроме Oracle, потому что реализация там не проста.</p>
<p>Параметр <code class="docutils literal notranslate"><span class="pre">format</span></code> изменяет формат вывода по умолчанию для баз данных, который обычно является текстовым. PostgreSQL поддерживает форматы <code class="docutils literal notranslate"><span class="pre">'TEXT'</span></code>, <code class="docutils literal notranslate"><span class="pre">'JSON'</span></code>, <code class="docutils literal notranslate"><span class="pre">'YAML'</span></code> и <code class="docutils literal notranslate"><span class="pre">'XML'</span></code>. MariaDB и MySQL поддерживают форматы <code class="docutils literal notranslate"><span class="pre">'TEXT'</span></code> (также называемые <code class="docutils literal notranslate"><span class="pre">'TRADITIONAL'</span></code>) и <code class="docutils literal notranslate"><span class="pre">'JSON'</span></code>. MySQL 8.0.16+ также поддерживает улучшенный формат <code class="docutils literal notranslate"><span class="pre">'TREE'</span></code>, который похож на вывод <code class="docutils literal notranslate"><span class="pre">'TEXT'</span></code> PostgreSQL и используется по умолчанию, если поддерживается.</p>
<p>Некоторые базы данных принимают флаги, которые могут возвращать больше информации о запросе. Передайте эти флаги в качестве ключевых аргументов. Например, при использовании PostgreSQL:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s">&#39;My Blog&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="k">True</span><span class="p">,</span> <span class="n">analyze</span><span class="o">=</span><span class="k">True</span><span class="p">))</span>
<span class="go">Seq Scan on public.blog  (cost=0.00..35.50 rows=10 width=12) (actual time=0.004..0.004 rows=10 loops=1)</span>
<span class="go">  Output: id, title</span>
<span class="go">  Filter: (blog.title = &#39;My Blog&#39;::bpchar)</span>
<span class="go">Planning time: 0.064 ms</span>
<span class="go">Execution time: 0.058 ms</span>
</pre></div>
</div>
<p>В некоторых базах данных флаги могут привести к выполнению запроса, что может отрицательно повлиять на вашу базу данных. Например, флаг <code class="docutils literal notranslate"><span class="pre">ANALYZE</span></code>, поддерживаемый MariaDB, MySQL 8.0.18+ и PostgreSQL, может привести к изменениям данных, если есть триггеры или если вызывается функция, даже для запроса <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>.</p>
<div class="versionchanged">
<span class="title">Changed in Django 3.1:</span> <p>Добавлена поддержка формата <code class="docutils literal notranslate"><span class="pre">'TREE'</span></code> в MySQL 8.0.16+ и опция <code class="docutils literal notranslate"><span class="pre">analysis</span></code> в MariaDB и MySQL 8.0.18+.</p>
</div>
</div>
</div>
<div class="section" id="s-field-lookups">
<span id="s-id4"></span><span id="field-lookups"></span><span id="id4"></span><h3>Поиск <code class="docutils literal notranslate"><span class="pre">Field</span></code><a class="headerlink" href="#field-lookups" title="Ссылка на этот заголовок">¶</a></h3>
<p>Поиск по полю - это то, как вы определяете содержание предложения SQL <code class="docutils literal notranslate"><span class="pre">WHERE</span></code>. Они указываются в качестве аргументов ключевых слов для методов <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> <a class="reference internal" href="#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a>, <a class="reference internal" href="#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exclude()</span></code></a> и <a class="reference internal" href="#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a>.</p>
<p>Для ознакомления смотрите <a class="reference internal" href="../../../topics/db/queries/#field-lookups-intro"><span class="std std-ref">документация по моделям и запросам к базе данных</span></a>.</p>
<p>Встроенные в Django поиски перечислены ниже. Также возможно написать <a class="reference internal" href="../../../howto/custom-lookups/"><span class="doc">собственные поиски</span></a> для полей модели.</p>
<p>Для удобства, когда не указан тип поиска (как в <code class="docutils literal notranslate"><span class="pre">Entry.objects.get(id=14)</span></code>), предполагается, что тип поиска <a class="reference internal" href="#std-fieldlookup-exact"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">exact</span></code></a>.</p>
<div class="section" id="s-exact">
<span id="s-std-fieldlookup-exact"></span><span id="s-std:fieldlookup-exact"></span><span id="exact"></span><span id="std-fieldlookup-exact"></span><span id="std:fieldlookup-exact"></span><h4><code class="docutils literal notranslate"><span class="pre">exact</span></code><a class="headerlink" href="#exact" title="Ссылка на этот заголовок">¶</a></h4>
<p>Точное совпадение. Если значение, предоставленное для сравнения, равно <code class="docutils literal notranslate"><span class="pre">None</span></code>, оно будет интерпретировано как SQL <code class="docutils literal notranslate"><span class="pre">NULL</span></code> (подробнее см. <a class="reference internal" href="#std-fieldlookup-isnull"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">isnull</span></code></a>).</p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="k">None</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition-mysql-comparisons admonition">
<p class="first admonition-title">MySQL сравнения</p>
<p class="last">В MySQL настройка «collation» таблицы базы данных определяет, являются ли <code class="docutils literal notranslate"><span class="pre">exact</span></code> сравнения чувствительными к регистру. Это настройка базы данных, а не настройка Django. Можно настроить ваши таблицы MySQL для использования чувствительных к регистру сравнений, но здесь есть некоторые компромиссы. Для получения дополнительной информации об этом смотрите раздел <a class="reference internal" href="../../databases/#mysql-collation"><span class="std std-ref">collation</span></a> в документации <a class="reference internal" href="../../databases/"><span class="doc">базы данных</span></a>.</p>
</div>
</div>
<div class="section" id="s-iexact">
<span id="s-std-fieldlookup-iexact"></span><span id="s-std:fieldlookup-iexact"></span><span id="iexact"></span><span id="std-fieldlookup-iexact"></span><span id="std:fieldlookup-iexact"></span><h4><code class="docutils literal notranslate"><span class="pre">iexact</span></code><a class="headerlink" href="#iexact" title="Ссылка на этот заголовок">¶</a></h4>
<p>Точное совпадение без учета регистра. Если значение, предоставленное для сравнения, равно <code class="docutils literal notranslate"><span class="pre">None</span></code>, оно будет интерпретировано как SQL <code class="docutils literal notranslate"><span class="pre">NULL</span></code> (подробнее смотрите <a class="reference internal" href="#std-fieldlookup-isnull"><code class="xref std std-lookup docutils literal notranslate"><span class="pre">isnull</span></code></a>).</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name__iexact</span><span class="o">=</span><span class="s">&#39;beatles blog&#39;</span><span class="p">)</span>
<span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name__iexact</span><span class="o">=</span><span class="k">None</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">name</span> <span class="k">ILIKE</span> <span class="s1">&#39;beatles blog&#39;</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">name</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">;</span>
</pre></div>
</div>
<p>Обратите внимание, что первый запрос будет соответствовать <code class="docutils literal notranslate"><span class="pre">'Beatles</span> <span class="pre">Blog'</span></code>, <code class="docutils literal notranslate"><span class="pre">'beatles</span> <span class="pre">blog'</span></code>, <code class="docutils literal notranslate"><span class="pre">'BeAtLes</span> <span class="pre">BLoG'</span></code> и т.д.</p>
<div class="admonition-sqlite-users admonition">
<p class="first admonition-title">Пользователи SQLite</p>
<p class="last">При использовании бэкэнда SQLite и строк, не относящихся к ASCII, помните про <a class="reference internal" href="../../databases/#sqlite-string-matching"><span class="std std-ref">примечание к базе данных</span></a> о сравнении строк. SQLite не выполняет сопоставление без учета регистра для не-ASCII-строк.</p>
</div>
</div>
<div class="section" id="s-contains">
<span id="s-std-fieldlookup-contains"></span><span id="s-std:fieldlookup-contains"></span><span id="contains"></span><span id="std-fieldlookup-contains"></span><span id="std:fieldlookup-contains"></span><h4><code class="docutils literal notranslate"><span class="pre">contains</span></code><a class="headerlink" href="#contains" title="Ссылка на этот заголовок">¶</a></h4>
<p>Чувствительная к регистру проверка вхождения.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">headline</span> <span class="k">LIKE</span> <span class="s1">&#39;%Lennon%&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>Обратите внимание, что это будет соответствовать заголовку <code class="docutils literal notranslate"><span class="pre">'Lennon</span> <span class="pre">honored</span> <span class="pre">today'</span></code> но не <code class="docutils literal notranslate"><span class="pre">'lennon</span> <span class="pre">honored</span> <span class="pre">today'</span></code>.</p>
<div class="admonition-sqlite-users admonition">
<p class="first admonition-title">Пользователи SQLite</p>
<p class="last">SQLite не поддерживает чувствительные к регистру операторы <code class="docutils literal notranslate"><span class="pre">LIKE</span></code>; <code class="docutils literal notranslate"><span class="pre">contains</span></code> действует как <code class="docutils literal notranslate"><span class="pre">icontains</span></code> для SQLite. Смотрите <a class="reference internal" href="../../databases/#sqlite-string-matching"><span class="std std-ref">примечание к базе данных</span></a> для получения дополнительной информации.</p>
</div>
</div>
<div class="section" id="s-icontains">
<span id="s-std-fieldlookup-icontains"></span><span id="s-std:fieldlookup-icontains"></span><span id="icontains"></span><span id="std-fieldlookup-icontains"></span><span id="std:fieldlookup-icontains"></span><h4><code class="docutils literal notranslate"><span class="pre">icontains</span></code><a class="headerlink" href="#icontains" title="Ссылка на этот заголовок">¶</a></h4>
<p>Нечувствительное к регистру проверка вхождения.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__icontains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">headline</span> <span class="k">ILIKE</span> <span class="s1">&#39;%Lennon%&#39;</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition-sqlite-users admonition">
<p class="first admonition-title">Пользователи SQLite</p>
<p class="last">При использовании бэкэнда SQLite и строк, не относящихся к ASCII, помните про <a class="reference internal" href="../../databases/#sqlite-string-matching"><span class="std std-ref">примечание к базе данных</span></a> о сравнении строк.</p>
</div>
</div>
<div class="section" id="s-in">
<span id="s-std-fieldlookup-in"></span><span id="s-std:fieldlookup-in"></span><span id="in"></span><span id="std-fieldlookup-in"></span><span id="std:fieldlookup-in"></span><h4><code class="docutils literal notranslate"><span class="pre">in</span></code><a class="headerlink" href="#in" title="Ссылка на этот заголовок">¶</a></h4>
<p>В данной итерации часто список, кортеж или набор запросов. Это не обычный случай использования, но строки (будучи итеративными) принимаются.</p>
<p>Примеры:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">id__in</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__in</span><span class="o">=</span><span class="s">&#39;abc&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">headline</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>Вы также можете использовать набор запросов для динамической оценки списка значений вместо предоставления списка литеральных значений:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">inner_qs</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s">&#39;Cheddar&#39;</span><span class="p">)</span>
<span class="n">entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__in</span><span class="o">=</span><span class="n">inner_qs</span><span class="p">)</span>
</pre></div>
</div>
<p>Этот набор запросов будет оцениваться как оператор подвыбора:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">blog</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">id</span> <span class="k">FROM</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">NAME</span> <span class="k">LIKE</span> <span class="s1">&#39;%Cheddar%&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Если вы передаете <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>, полученный в результате <code class="docutils literal notranslate"><span class="pre">values()</span></code> или <code class="docutils literal notranslate"><span class="pre">values_list()</span></code>, в качестве значения для поиска <code class="docutils literal notranslate"><span class="pre">__in</span></code>, вам нужно убедиться, что вы извлекаете только одно поле в результат. Например, это будет работать (фильтрация по именам блогов):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">inner_qs</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s">&#39;Ch&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">)</span>
<span class="n">entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__name__in</span><span class="o">=</span><span class="n">inner_qs</span><span class="p">)</span>
</pre></div>
</div>
<p>Этот пример вызовет исключение, поскольку внутренний запрос пытается извлечь два значения поля, где ожидается только одно:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="c"># Bad code! Will raise a TypeError.</span>
<span class="n">inner_qs</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s">&#39;Ch&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;id&#39;</span><span class="p">)</span>
<span class="n">entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__name__in</span><span class="o">=</span><span class="n">inner_qs</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-performance-considerations admonition" id="nested-queries-performance">
<p class="first admonition-title">Вопросы производительности</p>
<p>Будьте осторожны с использованием вложенных запросов и понимайте характеристики производительности сервера базы данных (если сомневаетесь, тестируйте!). Некоторые бэкэнды базы данных, особенно MySQL, не очень хорошо оптимизируют вложенные запросы. В этих случаях более эффективно извлечь список значений и затем передать его во второй запрос. То есть выполнить два запроса вместо одного:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">values</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">name__contains</span><span class="o">=</span><span class="s">&#39;Cheddar&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s">&#39;pk&#39;</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
<span class="n">entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__in</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
</pre></div>
</div>
<p class="last">Обратите внимание на вызов <code class="docutils literal notranslate"><span class="pre">list()</span></code> вокруг блога <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> для принудительного выполнения первого запроса. Без него будет выполнен вложенный запрос, потому что <a class="reference internal" href="../../../topics/db/queries/#querysets-are-lazy"><span class="std std-ref">`` QuerySet`` - ленивые</span></a>.</p>
</div>
</div>
<div class="section" id="s-gt">
<span id="s-std-fieldlookup-gt"></span><span id="s-std:fieldlookup-gt"></span><span id="gt"></span><span id="std-fieldlookup-gt"></span><span id="std:fieldlookup-gt"></span><h4><code class="docutils literal notranslate"><span class="pre">gt</span></code><a class="headerlink" href="#gt" title="Ссылка на этот заголовок">¶</a></h4>
<p>Больше чем.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">id__gt</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="s-gte">
<span id="s-std-fieldlookup-gte"></span><span id="s-std:fieldlookup-gte"></span><span id="gte"></span><span id="std-fieldlookup-gte"></span><span id="std:fieldlookup-gte"></span><h4><code class="docutils literal notranslate"><span class="pre">gte</span></code><a class="headerlink" href="#gte" title="Ссылка на этот заголовок">¶</a></h4>
<p>Больше или равно.</p>
</div>
<div class="section" id="s-lt">
<span id="s-std-fieldlookup-lt"></span><span id="s-std:fieldlookup-lt"></span><span id="lt"></span><span id="std-fieldlookup-lt"></span><span id="std:fieldlookup-lt"></span><h4><code class="docutils literal notranslate"><span class="pre">lt</span></code><a class="headerlink" href="#lt" title="Ссылка на этот заголовок">¶</a></h4>
<p>Меньше, чем.</p>
</div>
<div class="section" id="s-lte">
<span id="s-std-fieldlookup-lte"></span><span id="s-std:fieldlookup-lte"></span><span id="lte"></span><span id="std-fieldlookup-lte"></span><span id="std:fieldlookup-lte"></span><h4><code class="docutils literal notranslate"><span class="pre">lte</span></code><a class="headerlink" href="#lte" title="Ссылка на этот заголовок">¶</a></h4>
<p>Меньше или равно.</p>
</div>
<div class="section" id="s-startswith">
<span id="s-std-fieldlookup-startswith"></span><span id="s-std:fieldlookup-startswith"></span><span id="startswith"></span><span id="std-fieldlookup-startswith"></span><span id="std:fieldlookup-startswith"></span><h4><code class="docutils literal notranslate"><span class="pre">startswith</span></code><a class="headerlink" href="#startswith" title="Ссылка на этот заголовок">¶</a></h4>
<p>Начинается с (с учетом регистра).</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__startswith</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">headline</span> <span class="k">LIKE</span> <span class="s1">&#39;Lennon%&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>SQLite не поддерживает чувствительные к регистру операторы <code class="docutils literal notranslate"><span class="pre">LIKE</span></code>; <code class="docutils literal notranslate"><span class="pre">startswith</span></code> действует как <code class="docutils literal notranslate"><span class="pre">istartswith</span></code> для SQLite.</p>
</div>
<div class="section" id="s-istartswith">
<span id="s-std-fieldlookup-istartswith"></span><span id="s-std:fieldlookup-istartswith"></span><span id="istartswith"></span><span id="std-fieldlookup-istartswith"></span><span id="std:fieldlookup-istartswith"></span><h4><code class="docutils literal notranslate"><span class="pre">istartswith</span></code><a class="headerlink" href="#istartswith" title="Ссылка на этот заголовок">¶</a></h4>
<p>Начинается с (без учета регистра).</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__istartswith</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">headline</span> <span class="k">ILIKE</span> <span class="s1">&#39;Lennon%&#39;</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition-sqlite-users admonition">
<p class="first admonition-title">Пользователи SQLite</p>
<p class="last">При использовании бэкэнда SQLite и строк, не относящихся к ASCII, помните про <a class="reference internal" href="../../databases/#sqlite-string-matching"><span class="std std-ref">примечание к базе данных</span></a> о сравнении строк.</p>
</div>
</div>
<div class="section" id="s-endswith">
<span id="s-std-fieldlookup-endswith"></span><span id="s-std:fieldlookup-endswith"></span><span id="endswith"></span><span id="std-fieldlookup-endswith"></span><span id="std:fieldlookup-endswith"></span><h4><code class="docutils literal notranslate"><span class="pre">endswith</span></code><a class="headerlink" href="#endswith" title="Ссылка на этот заголовок">¶</a></h4>
<p>Заканчивается на (с учетом регистра).</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__endswith</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">headline</span> <span class="k">LIKE</span> <span class="s1">&#39;%Lennon&#39;</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition-sqlite-users admonition">
<p class="first admonition-title">Пользователи SQLite</p>
<p class="last">SQLite не поддерживает чувствительные к регистру операторы <code class="docutils literal notranslate"><span class="pre">LIKE</span></code>; <code class="docutils literal notranslate"><span class="pre">endswith</span></code> действует как <code class="docutils literal notranslate"><span class="pre">iendswith</span></code> для SQLite. Для получения дополнительной информации обратитесь к документации <a class="reference internal" href="../../databases/#sqlite-string-matching"><span class="std std-ref">замечания к базе данных</span></a>.</p>
</div>
</div>
<div class="section" id="s-iendswith">
<span id="s-std-fieldlookup-iendswith"></span><span id="s-std:fieldlookup-iendswith"></span><span id="iendswith"></span><span id="std-fieldlookup-iendswith"></span><span id="std:fieldlookup-iendswith"></span><h4><code class="docutils literal notranslate"><span class="pre">iendswith</span></code><a class="headerlink" href="#iendswith" title="Ссылка на этот заголовок">¶</a></h4>
<p>Заканчивается на (без учета регистра).</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__iendswith</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">headline</span> <span class="k">ILIKE</span> <span class="s1">&#39;%Lennon&#39;</span>
</pre></div>
</div>
<div class="admonition-sqlite-users admonition">
<p class="first admonition-title">Пользователи SQLite</p>
<p class="last">При использовании бэкэнда SQLite и строк, не относящихся к ASCII, помните про <a class="reference internal" href="../../databases/#sqlite-string-matching"><span class="std std-ref">примечание к базе данных</span></a> о сравнении строк.</p>
</div>
</div>
<div class="section" id="s-range">
<span id="s-std-fieldlookup-range"></span><span id="s-std:fieldlookup-range"></span><span id="range"></span><span id="std-fieldlookup-range"></span><span id="std:fieldlookup-range"></span><h4><code class="docutils literal notranslate"><span class="pre">range</span></code><a class="headerlink" href="#range" title="Ссылка на этот заголовок">¶</a></h4>
<p>Диапазон проверки (включительно).</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">datetime</span>
<span class="n">start_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">end_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">31</span><span class="p">)</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__range</span><span class="o">=</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">))</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">pub_date</span> <span class="k">BETWEEN</span> <span class="s1">&#39;2005-01-01&#39;</span> <span class="k">and</span> <span class="s1">&#39;2005-03-31&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>Вы можете использовать <code class="docutils literal notranslate"><span class="pre">range</span></code> везде, где можете использовать <code class="docutils literal notranslate"><span class="pre">BETWEEN</span></code> в SQL - для дат, чисел и даже символов.</p>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p>Фильтрация <code class="docutils literal notranslate"><span class="pre">DateTimeField</span></code> с датами не будет включать элементы в последний день, потому что границы интерпретируются как «0:00 на данную дату». Если бы <code class="docutils literal notranslate"><span class="pre">pub_date</span></code> был <code class="docutils literal notranslate"><span class="pre">DateTimeField</span></code>, вышеприведенное выражение превратилось бы в этот SQL:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">pub_date</span> <span class="k">BETWEEN</span> <span class="s1">&#39;2005-01-01 00:00:00&#39;</span> <span class="k">and</span> <span class="s1">&#39;2005-03-31 00:00:00&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p class="last">Вообще говоря, вы не можете смешивать даты и время.</p>
</div>
</div>
<div class="section" id="s-date">
<span id="s-std-fieldlookup-date"></span><span id="s-std:fieldlookup-date"></span><span id="date"></span><span id="std-fieldlookup-date"></span><span id="std:fieldlookup-date"></span><h4><code class="docutils literal notranslate"><span class="pre">date</span></code><a class="headerlink" href="#date" title="Ссылка на этот заголовок">¶</a></h4>
<p>Для полей даты и времени преобразует значение как дату. Позволяет цепочки дополнительных поисков по полям. Принимает значение даты.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__date</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__date__gt</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>(Эквивалентный фрагмент кода SQL для этого поиска не включен, поскольку реализация соответствующего запроса варьируется в зависимости от разных механизмов баз данных.)</p>
<p>Когда <a class="reference internal" href="../../settings/#std-setting-USE_TZ"><code class="xref std std-setting docutils literal notranslate"><span class="pre">USE_TZ</span></code></a> равно <code class="docutils literal notranslate"><span class="pre">True</span></code>, поля преобразуются в текущий часовой пояс перед фильтрацией. Для этого требуется <a class="reference internal" href="#database-time-zone-definitions"><span class="std std-ref">определение часовых поясов в базе данных</span></a>.</p>
</div>
<div class="section" id="s-year">
<span id="s-std-fieldlookup-year"></span><span id="s-std:fieldlookup-year"></span><span id="year"></span><span id="std-fieldlookup-year"></span><span id="std:fieldlookup-year"></span><h4><code class="docutils literal notranslate"><span class="pre">year</span></code><a class="headerlink" href="#year" title="Ссылка на этот заголовок">¶</a></h4>
<p>Для полей даты и даты и времени точное совпадение года. Позволяет цепочки дополнительных поисков по полям. Принимает целое число - год.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year__gte</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">pub_date</span> <span class="k">BETWEEN</span> <span class="s1">&#39;2005-01-01&#39;</span> <span class="k">AND</span> <span class="s1">&#39;2005-12-31&#39;</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">pub_date</span> <span class="o">&gt;=</span> <span class="s1">&#39;2005-01-01&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>(Точный синтаксис SQL варьируется для каждого механизма базы данных.)</p>
<p>Когда <a class="reference internal" href="../../settings/#std-setting-USE_TZ"><code class="xref std std-setting docutils literal notranslate"><span class="pre">USE_TZ</span></code></a> равно <code class="docutils literal notranslate"><span class="pre">True</span></code>, поля даты и времени преобразуются в текущий часовой пояс перед фильтрацией. Для этого требуется <a class="reference internal" href="#database-time-zone-definitions"><span class="std std-ref">определение часовых поясов в базе данных</span></a>.</p>
</div>
<div class="section" id="s-iso-year">
<span id="s-std-fieldlookup-iso_year"></span><span id="s-std:fieldlookup-iso_year"></span><span id="iso-year"></span><span id="std-fieldlookup-iso_year"></span><span id="std:fieldlookup-iso_year"></span><h4><code class="docutils literal notranslate"><span class="pre">iso_year</span></code><a class="headerlink" href="#iso-year" title="Ссылка на этот заголовок">¶</a></h4>
<p>Для полей даты и даты и времени точно указан год недели с номером нумерации ISO 8601. Позволяет цепочки дополнительных полевых поисков. Принимает целое число - год.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__iso_year</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__iso_year__gte</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span>
</pre></div>
</div>
<p>(Точный синтаксис SQL варьируется для каждого механизма базы данных.)</p>
<p>Когда <a class="reference internal" href="../../settings/#std-setting-USE_TZ"><code class="xref std std-setting docutils literal notranslate"><span class="pre">USE_TZ</span></code></a> равно <code class="docutils literal notranslate"><span class="pre">True</span></code>, поля даты и времени преобразуются в текущий часовой пояс перед фильтрацией. Для этого требуется <a class="reference internal" href="#database-time-zone-definitions"><span class="std std-ref">определение часовых поясов в базе данных</span></a>.</p>
</div>
<div class="section" id="s-month">
<span id="s-std-fieldlookup-month"></span><span id="s-std:fieldlookup-month"></span><span id="month"></span><span id="std-fieldlookup-month"></span><span id="std:fieldlookup-month"></span><h4><code class="docutils literal notranslate"><span class="pre">month</span></code><a class="headerlink" href="#month" title="Ссылка на этот заголовок">¶</a></h4>
<p>Для полей даты и даты и времени точное совпадение месяцев. Позволяет цепочки дополнительных поисков по полям. Принимает целое число от 1 (январь) до 12 (декабрь).</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__month</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__month__gte</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="k">EXTRACT</span><span class="p">(</span><span class="s1">&#39;month&#39;</span> <span class="k">FROM</span> <span class="n">pub_date</span><span class="p">)</span> <span class="o">=</span> <span class="s1">&#39;12&#39;</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="k">EXTRACT</span><span class="p">(</span><span class="s1">&#39;month&#39;</span> <span class="k">FROM</span> <span class="n">pub_date</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="s1">&#39;6&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>(Точный синтаксис SQL варьируется для каждого механизма базы данных.)</p>
<p>Когда <a class="reference internal" href="../../settings/#std-setting-USE_TZ"><code class="xref std std-setting docutils literal notranslate"><span class="pre">USE_TZ</span></code></a> равно <code class="docutils literal notranslate"><span class="pre">True</span></code>, поля даты и времени преобразуются в текущий часовой пояс перед фильтрацией. Для этого требуется <a class="reference internal" href="#database-time-zone-definitions"><span class="std std-ref">определение часовых поясов в базе данных</span></a>.</p>
</div>
<div class="section" id="s-day">
<span id="s-std-fieldlookup-day"></span><span id="s-std:fieldlookup-day"></span><span id="day"></span><span id="std-fieldlookup-day"></span><span id="std:fieldlookup-day"></span><h4><code class="docutils literal notranslate"><span class="pre">day</span></code><a class="headerlink" href="#day" title="Ссылка на этот заголовок">¶</a></h4>
<p>Для полей даты и даты и времени - точное совпадение дня. Позволяет цепочки дополнительных поисков по полям. Принимает целое число - день.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__day</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__day__gte</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="k">EXTRACT</span><span class="p">(</span><span class="s1">&#39;day&#39;</span> <span class="k">FROM</span> <span class="n">pub_date</span><span class="p">)</span> <span class="o">=</span> <span class="s1">&#39;3&#39;</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="k">EXTRACT</span><span class="p">(</span><span class="s1">&#39;day&#39;</span> <span class="k">FROM</span> <span class="n">pub_date</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="s1">&#39;3&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>(Точный синтаксис SQL варьируется для каждого механизма базы данных.)</p>
<p>Обратите внимание, что это будет соответствовать любой записи с pub_date в третий день месяца, например 3 января, 3 июля и т.д.</p>
<p>Когда <a class="reference internal" href="../../settings/#std-setting-USE_TZ"><code class="xref std std-setting docutils literal notranslate"><span class="pre">USE_TZ</span></code></a> равно <code class="docutils literal notranslate"><span class="pre">True</span></code>, поля даты и времени преобразуются в текущий часовой пояс перед фильтрацией. Для этого требуется <a class="reference internal" href="#database-time-zone-definitions"><span class="std std-ref">определение часовых поясов в базе данных</span></a>.</p>
</div>
<div class="section" id="s-week">
<span id="s-std-fieldlookup-week"></span><span id="s-std:fieldlookup-week"></span><span id="week"></span><span id="std-fieldlookup-week"></span><span id="std:fieldlookup-week"></span><h4><code class="docutils literal notranslate"><span class="pre">week</span></code><a class="headerlink" href="#week" title="Ссылка на этот заголовок">¶</a></h4>
<p>Для полей даты и даты и времени возвращает номер недели (1-52 или 53) в соответствии с ISO-8601 &lt;https://en.wikipedia.org/wiki/ISO-8601&gt; _, то есть недели, начинающиеся в понедельник и первая неделя содержит первый четверг года.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__week</span><span class="o">=</span><span class="mi">52</span><span class="p">)</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__week__gte</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">pub_date__week__lte</span><span class="o">=</span><span class="mi">38</span><span class="p">)</span>
</pre></div>
</div>
<p>(Эквивалентный фрагмент кода SQL для этого поиска не включен, поскольку реализация соответствующего запроса варьируется в зависимости от разных механизмов баз данных.)</p>
<p>Когда <a class="reference internal" href="../../settings/#std-setting-USE_TZ"><code class="xref std std-setting docutils literal notranslate"><span class="pre">USE_TZ</span></code></a> равно <code class="docutils literal notranslate"><span class="pre">True</span></code>, поля даты и времени преобразуются в текущий часовой пояс перед фильтрацией. Для этого требуется <a class="reference internal" href="#database-time-zone-definitions"><span class="std std-ref">определение часовых поясов в базе данных</span></a>.</p>
</div>
<div class="section" id="s-week-day">
<span id="s-std-fieldlookup-week_day"></span><span id="s-std:fieldlookup-week_day"></span><span id="week-day"></span><span id="std-fieldlookup-week_day"></span><span id="std:fieldlookup-week_day"></span><h4><code class="docutils literal notranslate"><span class="pre">week_day</span></code><a class="headerlink" href="#week-day" title="Ссылка на этот заголовок">¶</a></h4>
<p>Для полей даты и даты и времени соответствует «день недели». Позволяет цепочки дополнительных поисков.</p>
<p>Принимает целочисленное значение, представляющее день недели от 1 (воскресенье) до 7 (суббота).</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__week_day</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__week_day__gte</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>(Эквивалентный фрагмент кода SQL для этого поиска не включен, поскольку реализация соответствующего запроса варьируется в зависимости от разных механизмов баз данных.)</p>
<p>Обратите внимание, что это будет соответствовать любой записи с <code class="docutils literal notranslate"><span class="pre">pub_date</span></code>, которая выпадает на понедельник (2-ой день недели), независимо от месяца или года, в котором она происходит. Дни недели индексируются, причем день 1 - воскресенье, а день 7 - суббота.</p>
<p>Когда <a class="reference internal" href="../../settings/#std-setting-USE_TZ"><code class="xref std std-setting docutils literal notranslate"><span class="pre">USE_TZ</span></code></a> равно <code class="docutils literal notranslate"><span class="pre">True</span></code>, поля даты и времени преобразуются в текущий часовой пояс перед фильтрацией. Для этого требуется <a class="reference internal" href="#database-time-zone-definitions"><span class="std std-ref">определение часовых поясов в базе данных</span></a>.</p>
</div>
<div class="section" id="s-iso-week-day">
<span id="s-std-fieldlookup-iso_week_day"></span><span id="s-std:fieldlookup-iso_week_day"></span><span id="iso-week-day"></span><span id="std-fieldlookup-iso_week_day"></span><span id="std:fieldlookup-iso_week_day"></span><h4><code class="docutils literal notranslate"><span class="pre">iso_week_day</span></code><a class="headerlink" href="#iso-week-day" title="Ссылка на этот заголовок">¶</a></h4>
<div class="versionadded">
<span class="title">New in Django 3.1.</span> </div>
<p>Для полей даты и даты-времени точный день недели соответствует ISO 8601. Позволяет цепочки дополнительных поисков.</p>
<p>Принимает целочисленное значение, представляющее день недели от 1 (воскресенье) до 7 (суббота).</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__iso_week_day</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__iso_week_day__gte</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>(Эквивалентный фрагмент кода SQL для этого поиска не включен, поскольку реализация соответствующего запроса варьируется в зависимости от разных механизмов баз данных.)</p>
<p>Обратите внимание, что это будет соответствовать любой записи с <code class="docutils literal notranslate"><span class="pre">pub_date</span></code>, которая выпадает на понедельник (1-й день недели), независимо от месяца или года, в котором она происходит. Дни недели индексируются, причем день 1 - понедельник, а день 7 - воскресенье.</p>
<p>Когда <a class="reference internal" href="../../settings/#std-setting-USE_TZ"><code class="xref std std-setting docutils literal notranslate"><span class="pre">USE_TZ</span></code></a> равно <code class="docutils literal notranslate"><span class="pre">True</span></code>, поля даты и времени преобразуются в текущий часовой пояс перед фильтрацией. Для этого требуется <a class="reference internal" href="#database-time-zone-definitions"><span class="std std-ref">определение часовых поясов в базе данных</span></a>.</p>
</div>
<div class="section" id="s-quarter">
<span id="s-std-fieldlookup-quarter"></span><span id="s-std:fieldlookup-quarter"></span><span id="quarter"></span><span id="std-fieldlookup-quarter"></span><span id="std:fieldlookup-quarter"></span><h4><code class="docutils literal notranslate"><span class="pre">quarter</span></code><a class="headerlink" href="#quarter" title="Ссылка на этот заголовок">¶</a></h4>
<p>Для полей даты и даты и времени соответствующий квартал года. Позволяет цепочки дополнительных поисков. Принимает целое значение от 1 до 4, представляющее квартал года.</p>
<p>Пример получения записей во втором квартале (с 1 апреля по 30 июня):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__quarter</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>(Эквивалентный фрагмент кода SQL для этого поиска не включен, поскольку реализация соответствующего запроса варьируется в зависимости от разных механизмов баз данных.)</p>
<p>Когда <a class="reference internal" href="../../settings/#std-setting-USE_TZ"><code class="xref std std-setting docutils literal notranslate"><span class="pre">USE_TZ</span></code></a> равно <code class="docutils literal notranslate"><span class="pre">True</span></code>, поля даты и времени преобразуются в текущий часовой пояс перед фильтрацией. Для этого требуется <a class="reference internal" href="#database-time-zone-definitions"><span class="std std-ref">определение часовых поясов в базе данных</span></a>.</p>
</div>
<div class="section" id="s-time">
<span id="s-std-fieldlookup-time"></span><span id="s-std:fieldlookup-time"></span><span id="time"></span><span id="std-fieldlookup-time"></span><span id="std:fieldlookup-time"></span><h4><code class="docutils literal notranslate"><span class="pre">time</span></code><a class="headerlink" href="#time" title="Ссылка на этот заголовок">¶</a></h4>
<p>Для полей даты и времени преобразует значение как время. Позволяет цепочки дополнительных поисков. Принимает значение <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.time" title="(в Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.time</span></code></a>.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__time</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">30</span><span class="p">))</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__time__range</span><span class="o">=</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">datetime</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="mi">17</span><span class="p">)))</span>
</pre></div>
</div>
<p>(Эквивалентный фрагмент кода SQL для этого поиска не включен, поскольку реализация соответствующего запроса варьируется в зависимости от разных механизмов баз данных.)</p>
<p>Когда <a class="reference internal" href="../../settings/#std-setting-USE_TZ"><code class="xref std std-setting docutils literal notranslate"><span class="pre">USE_TZ</span></code></a> равно <code class="docutils literal notranslate"><span class="pre">True</span></code>, поля преобразуются в текущий часовой пояс перед фильтрацией. Для этого требуется <a class="reference internal" href="#database-time-zone-definitions"><span class="std std-ref">определение часовых поясов в базе данных</span></a>.</p>
</div>
<div class="section" id="s-hour">
<span id="s-std-fieldlookup-hour"></span><span id="s-std:fieldlookup-hour"></span><span id="hour"></span><span id="std-fieldlookup-hour"></span><span id="std:fieldlookup-hour"></span><h4><code class="docutils literal notranslate"><span class="pre">hour</span></code><a class="headerlink" href="#hour" title="Ссылка на этот заголовок">¶</a></h4>
<p>Для полей даты и времени точное совпадение часов. Позволяет цепочки дополнительных поисков. Принимает целое число от 0 до 23.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Event</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">timestamp__hour</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
<span class="n">Event</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">time__hour</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">Event</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">timestamp__hour__gte</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="k">EXTRACT</span><span class="p">(</span><span class="s1">&#39;hour&#39;</span> <span class="k">FROM</span> <span class="k">timestamp</span><span class="p">)</span> <span class="o">=</span> <span class="s1">&#39;23&#39;</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="k">EXTRACT</span><span class="p">(</span><span class="s1">&#39;hour&#39;</span> <span class="k">FROM</span> <span class="n">time</span><span class="p">)</span> <span class="o">=</span> <span class="s1">&#39;5&#39;</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="k">EXTRACT</span><span class="p">(</span><span class="s1">&#39;hour&#39;</span> <span class="k">FROM</span> <span class="k">timestamp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="s1">&#39;12&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>(Точный синтаксис SQL варьируется для каждого механизма базы данных.)</p>
<p>Когда <a class="reference internal" href="../../settings/#std-setting-USE_TZ"><code class="xref std std-setting docutils literal notranslate"><span class="pre">USE_TZ</span></code></a> равно <code class="docutils literal notranslate"><span class="pre">True</span></code>, поля даты и времени преобразуются в текущий часовой пояс перед фильтрацией. Для этого требуется <a class="reference internal" href="#database-time-zone-definitions"><span class="std std-ref">определение часовых поясов в базе данных</span></a>.</p>
</div>
<div class="section" id="s-minute">
<span id="s-std-fieldlookup-minute"></span><span id="s-std:fieldlookup-minute"></span><span id="minute"></span><span id="std-fieldlookup-minute"></span><span id="std:fieldlookup-minute"></span><h4><code class="docutils literal notranslate"><span class="pre">minute</span></code><a class="headerlink" href="#minute" title="Ссылка на этот заголовок">¶</a></h4>
<p>Для полей даты и времени, точное совпадение минут. Позволяет цепочки дополнительных поисков. Принимает целое число от 0 до 59.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Event</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">timestamp__minute</span><span class="o">=</span><span class="mi">29</span><span class="p">)</span>
<span class="n">Event</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">time__minute</span><span class="o">=</span><span class="mi">46</span><span class="p">)</span>
<span class="n">Event</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">timestamp__minute__gte</span><span class="o">=</span><span class="mi">29</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="k">EXTRACT</span><span class="p">(</span><span class="s1">&#39;minute&#39;</span> <span class="k">FROM</span> <span class="k">timestamp</span><span class="p">)</span> <span class="o">=</span> <span class="s1">&#39;29&#39;</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="k">EXTRACT</span><span class="p">(</span><span class="s1">&#39;minute&#39;</span> <span class="k">FROM</span> <span class="n">time</span><span class="p">)</span> <span class="o">=</span> <span class="s1">&#39;46&#39;</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="k">EXTRACT</span><span class="p">(</span><span class="s1">&#39;minute&#39;</span> <span class="k">FROM</span> <span class="k">timestamp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="s1">&#39;29&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>(Точный синтаксис SQL варьируется для каждого механизма базы данных.)</p>
<p>Когда <a class="reference internal" href="../../settings/#std-setting-USE_TZ"><code class="xref std std-setting docutils literal notranslate"><span class="pre">USE_TZ</span></code></a> равно <code class="docutils literal notranslate"><span class="pre">True</span></code>, поля даты и времени преобразуются в текущий часовой пояс перед фильтрацией. Для этого требуется <a class="reference internal" href="#database-time-zone-definitions"><span class="std std-ref">определение часовых поясов в базе данных</span></a>.</p>
</div>
<div class="section" id="s-second">
<span id="s-std-fieldlookup-second"></span><span id="s-std:fieldlookup-second"></span><span id="second"></span><span id="std-fieldlookup-second"></span><span id="std:fieldlookup-second"></span><h4><code class="docutils literal notranslate"><span class="pre">second</span></code><a class="headerlink" href="#second" title="Ссылка на этот заголовок">¶</a></h4>
<p>Для полей даты и времени точное совпадение секунд. Позволяет цепочки дополнительных поисков. Принимает целое число от 0 до 59.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Event</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">timestamp__second</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
<span class="n">Event</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">time__second</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Event</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">timestamp__second__gte</span><span class="o">=</span><span class="mi">31</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="k">EXTRACT</span><span class="p">(</span><span class="s1">&#39;second&#39;</span> <span class="k">FROM</span> <span class="k">timestamp</span><span class="p">)</span> <span class="o">=</span> <span class="s1">&#39;31&#39;</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="k">EXTRACT</span><span class="p">(</span><span class="s1">&#39;second&#39;</span> <span class="k">FROM</span> <span class="n">time</span><span class="p">)</span> <span class="o">=</span> <span class="s1">&#39;2&#39;</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="k">EXTRACT</span><span class="p">(</span><span class="s1">&#39;second&#39;</span> <span class="k">FROM</span> <span class="k">timestamp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="s1">&#39;31&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>(Точный синтаксис SQL варьируется для каждого механизма базы данных.)</p>
<p>Когда <a class="reference internal" href="../../settings/#std-setting-USE_TZ"><code class="xref std std-setting docutils literal notranslate"><span class="pre">USE_TZ</span></code></a> равно <code class="docutils literal notranslate"><span class="pre">True</span></code>, поля даты и времени преобразуются в текущий часовой пояс перед фильтрацией. Для этого требуется <a class="reference internal" href="#database-time-zone-definitions"><span class="std std-ref">определение часовых поясов в базе данных</span></a>.</p>
</div>
<div class="section" id="s-isnull">
<span id="s-std-fieldlookup-isnull"></span><span id="s-std:fieldlookup-isnull"></span><span id="isnull"></span><span id="std-fieldlookup-isnull"></span><span id="std:fieldlookup-isnull"></span><h4><code class="docutils literal notranslate"><span class="pre">isnull</span></code><a class="headerlink" href="#isnull" title="Ссылка на этот заголовок">¶</a></h4>
<p>Принимает <code class="docutils literal notranslate"><span class="pre">True</span></code> или <code class="docutils literal notranslate"><span class="pre">False</span></code>, которые соответствуют SQL-запросам <code class="docutils literal notranslate"><span class="pre">IS</span> <span class="pre">NULL</span></code> и <code class="docutils literal notranslate"><span class="pre">IS</span> <span class="pre">NOT</span> <span class="pre">NULL</span></code>, соответственно.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__isnull</span><span class="o">=</span><span class="k">True</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">pub_date</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">;</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">Не рекомендуется, начиная с версии 3.1: </span>Использование не булевых значений в качестве правой части устарело, используйте взамен <code class="docutils literal notranslate"><span class="pre">True</span></code> или <code class="docutils literal notranslate"><span class="pre">False</span></code>. В Django 4.0 будет выбрасываться исключение.</p>
</div>
</div>
<div class="section" id="s-regex">
<span id="s-std-fieldlookup-regex"></span><span id="s-std:fieldlookup-regex"></span><span id="regex"></span><span id="std-fieldlookup-regex"></span><span id="std:fieldlookup-regex"></span><h4><code class="docutils literal notranslate"><span class="pre">regex</span></code><a class="headerlink" href="#regex" title="Ссылка на этот заголовок">¶</a></h4>
<p>Чувствительное к регистру совпадение регулярного выражения.</p>
<p>Синтаксис регулярного выражения - это используемый серверный компонент базы данных. В случае SQLite, который не имеет встроенной поддержки регулярных выражений, эта функция обеспечивается пользовательской функцией REGEXP (Python), поэтому синтаксис регулярного выражения является синтаксисом модуля <code class="docutils literal notranslate"><span class="pre">re</span></code> в Python.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">title__regex</span><span class="o">=</span><span class="s">r&#39;^(An?|The) +&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">title</span> <span class="n">REGEXP</span> <span class="nb">BINARY</span> <span class="s1">&#39;^(An?|The) +&#39;</span><span class="p">;</span> <span class="c1">-- MySQL</span>

<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">REGEXP_LIKE</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="s1">&#39;^(An?|The) +&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">);</span> <span class="c1">-- Oracle</span>

<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">title</span> <span class="o">~</span> <span class="s1">&#39;^(An?|The) +&#39;</span><span class="p">;</span> <span class="c1">-- PostgreSQL</span>

<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">title</span> <span class="n">REGEXP</span> <span class="s1">&#39;^(An?|The) +&#39;</span><span class="p">;</span> <span class="c1">-- SQLite</span>
</pre></div>
</div>
<p>Рекомендуется использовать необработанные строки (например, <code class="docutils literal notranslate"><span class="pre">r'foo'</span></code> вместо <code class="docutils literal notranslate"><span class="pre">'foo'</span></code>) для передачи синтаксиса регулярного выражения.</p>
</div>
<div class="section" id="s-iregex">
<span id="s-std-fieldlookup-iregex"></span><span id="s-std:fieldlookup-iregex"></span><span id="iregex"></span><span id="std-fieldlookup-iregex"></span><span id="std:fieldlookup-iregex"></span><h4><code class="docutils literal notranslate"><span class="pre">iregex</span></code><a class="headerlink" href="#iregex" title="Ссылка на этот заголовок">¶</a></h4>
<p>Нечувствительное к регистру совпадение регулярного выражения.</p>
<p>Пример:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">title__iregex</span><span class="o">=</span><span class="s">r&#39;^(an?|the) +&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>SQL-эквивалент:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">title</span> <span class="n">REGEXP</span> <span class="s1">&#39;^(an?|the) +&#39;</span><span class="p">;</span> <span class="c1">-- MySQL</span>

<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">REGEXP_LIKE</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="s1">&#39;^(an?|the) +&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">);</span> <span class="c1">-- Oracle</span>

<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">title</span> <span class="o">~*</span> <span class="s1">&#39;^(an?|the) +&#39;</span><span class="p">;</span> <span class="c1">-- PostgreSQL</span>

<span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">title</span> <span class="n">REGEXP</span> <span class="s1">&#39;(?i)^(an?|the) +&#39;</span><span class="p">;</span> <span class="c1">-- SQLite</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="s-aggregation-functions">
<span id="s-id5"></span><span id="aggregation-functions"></span><span id="id5"></span><h3>Агрегационные функции<a class="headerlink" href="#aggregation-functions" title="Ссылка на этот заголовок">¶</a></h3>
<p>Django предоставляет следующие функции агрегирования в модуле <code class="docutils literal notranslate"><span class="pre">django.db.models</span></code>. Подробнее о том, как использовать эти агрегатные функции, смотрите <a class="reference internal" href="../../../topics/db/aggregation/"><span class="doc">руководство по агрегации тем</span></a>. Обратитесь к документации <a class="reference internal" href="../expressions/#django.db.models.Aggregate" title="django.db.models.Aggregate"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregate</span></code></a>, чтобы узнать, как создавать агрегаты.</p>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p class="last">SQLite не может обрабатывать агрегирование полей даты/времени «из коробки». Это связано с тем, что в SQLite нет собственных полей даты и времени, а Django в настоящее время эмулирует эти функции с помощью текстового поля. Попытки использовать агрегирование полей даты/времени в SQLite вызовут <code class="docutils literal notranslate"><span class="pre">NotSupportedError</span></code>.</p>
</div>
<div class="admonition-note admonition">
<p class="first admonition-title">Примечание</p>
<p class="last">Функции агрегирования возвращают <code class="docutils literal notranslate"><span class="pre">None</span></code> при использовании с пустым <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>. Например, функция агрегирования <code class="docutils literal notranslate"><span class="pre">Sum</span></code> возвращает <code class="docutils literal notranslate"><span class="pre">None</span></code> вместо <code class="docutils literal notranslate"><span class="pre">0</span></code>, если <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> не содержит записей. Исключением является <code class="docutils literal notranslate"><span class="pre">Count</span></code>, который возвращает <code class="docutils literal notranslate"><span class="pre">0</span></code>, если <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> пуст.</p>
</div>
<p>Все агрегаты имеют следующие общие параметры:</p>
<div class="section" id="s-expressions">
<span id="expressions"></span><h4><code class="docutils literal notranslate"><span class="pre">expressions</span></code><a class="headerlink" href="#expressions" title="Ссылка на этот заголовок">¶</a></h4>
<p>Строки, которые ссылаются на поля в модели, или <a class="reference internal" href="../expressions/"><span class="doc">выражения запроса</span></a>.</p>
</div>
<div class="section" id="s-output-field">
<span id="output-field"></span><h4><code class="docutils literal notranslate"><span class="pre">output_field</span></code><a class="headerlink" href="#output-field" title="Ссылка на этот заголовок">¶</a></h4>
<p>Необязательный аргумент, представляющий <a class="reference internal" href="../fields/"><span class="doc">поле модели</span></a> возвращаемого значения</p>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p class="last">При объединении нескольких типов полей Django может определить <code class="docutils literal notranslate"><span class="pre">output_field</span></code>, только если все поля одного типа. В противном случае вы должны предоставить <code class="docutils literal notranslate"><span class="pre">output_field</span></code> самостоятельно.</p>
</div>
</div>
<div class="section" id="s-aggregate-filter">
<span id="s-id6"></span><span id="aggregate-filter"></span><span id="id6"></span><h4><code class="docutils literal notranslate"><span class="pre">filter</span></code><a class="headerlink" href="#aggregate-filter" title="Ссылка на этот заголовок">¶</a></h4>
<p>Необязательный <a class="reference internal" href="#django.db.models.Q" title="django.db.models.Q"><code class="xref py py-class docutils literal notranslate"><span class="pre">Q</span> <span class="pre">object</span></code></a>, который используется для фильтрации агрегируемых строк.</p>
<p>Смотрите <a class="reference internal" href="../conditional-expressions/#conditional-aggregation"><span class="std std-ref">Условная агрегация</span></a> и <a class="reference internal" href="../../../topics/db/aggregation/#filtering-on-annotations"><span class="std std-ref">Фильтрация по аннотациям</span></a>.</p>
</div>
<div class="section" id="s-id7">
<span id="id7"></span><h4><code class="docutils literal notranslate"><span class="pre">**extra</span></code><a class="headerlink" href="#id7" title="Ссылка на этот заголовок">¶</a></h4>
<p>Аргументы ключевых слов, которые могут предоставить дополнительный контекст для SQL, сгенерированного агрегатом.</p>
</div>
<div class="section" id="s-avg">
<span id="avg"></span><h4><code class="docutils literal notranslate"><span class="pre">Avg</span></code><a class="headerlink" href="#avg" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py class">
<dt id="django.db.models.Avg">
<em class="property">class </em><code class="descname">Avg</code>(<em><span class="n">expression</span></em>, <em><span class="n">output_field</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">distinct</span><span class="o">=</span><span class="default_value">False</span></em>, <em><span class="n">filter</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="o">**</span><span class="n">extra</span></em>)<a class="reference internal" href="../../../_modules/django/db/models/aggregates/#Avg"><span class="viewcode-link">[исходный код]</span></a><a class="headerlink" href="#django.db.models.Avg" title="Ссылка на это определение">¶</a></dt>
<dd><p>Возвращает среднее значение заданного выражения, которое должно быть числовым, если вы не укажете другое <code class="docutils literal notranslate"><span class="pre">output_field</span></code>.</p>
<ul class="simple">
<li>Псевдоним по умолчанию: <code class="docutils literal notranslate"><span class="pre">&lt;field&gt;__avg</span></code></li>
<li>Тип возвращаемого значения: <code class="docutils literal notranslate"><span class="pre">float</span></code>, если на входе <code class="docutils literal notranslate"><span class="pre">int</span></code>, в остальном то же самое, что и поле ввода, или <code class="docutils literal notranslate"><span class="pre">output_field</span></code>, если он указан</li>
</ul>
<p>Имеет один необязательный аргумент:</p>
<dl class="py attribute">
<dt id="django.db.models.Avg.distinct">
<code class="descname">distinct</code><a class="headerlink" href="#django.db.models.Avg.distinct" title="Ссылка на это определение">¶</a></dt>
<dd><p>Если <code class="docutils literal notranslate"><span class="pre">Different=True</span></code>, <code class="docutils literal notranslate"><span class="pre">Avg</span></code> возвращает среднее значение уникальных значений. Это SQL-эквивалент <code class="docutils literal notranslate"><span class="pre">AVG(DISTINCT</span> <span class="pre">&lt;field&gt;)</span></code>. Значением по умолчанию является <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<div class="versionchanged">
<span class="title">Changed in Django 3.0:</span> <p>Добавлена поддержка <code class="docutils literal notranslate"><span class="pre">distinct=True</span></code>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="s-id8">
<span id="id8"></span><h4><code class="docutils literal notranslate"><span class="pre">Count</span></code><a class="headerlink" href="#id8" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py class">
<dt id="django.db.models.Count">
<em class="property">class </em><code class="descname">Count</code>(<em><span class="n">expression</span></em>, <em><span class="n">distinct</span><span class="o">=</span><span class="default_value">False</span></em>, <em><span class="n">filter</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="o">**</span><span class="n">extra</span></em>)<a class="reference internal" href="../../../_modules/django/db/models/aggregates/#Count"><span class="viewcode-link">[исходный код]</span></a><a class="headerlink" href="#django.db.models.Count" title="Ссылка на это определение">¶</a></dt>
<dd><p>Возвращает количество объектов, связанных через предоставленное выражение.</p>
<ul class="simple">
<li>Псевдоним по умолчанию: <code class="docutils literal notranslate"><span class="pre">&lt;field&gt;__count</span></code></li>
<li>Тип возврата: `` int``</li>
</ul>
<p>Имеет один необязательный аргумент:</p>
<dl class="py attribute">
<dt id="django.db.models.Count.distinct">
<code class="descname">distinct</code><a class="headerlink" href="#django.db.models.Count.distinct" title="Ссылка на это определение">¶</a></dt>
<dd><p>Если <code class="docutils literal notranslate"><span class="pre">distinct=True</span></code>, в число будут включены только уникальные экземпляры. Это эквивалент SQL <code class="docutils literal notranslate"><span class="pre">COUNT</span> <span class="pre">(DISTINCT</span> <span class="pre">&lt;field&gt;)</span></code>. Значением по умолчанию является <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="s-max">
<span id="max"></span><h4><code class="docutils literal notranslate"><span class="pre">Max</span></code><a class="headerlink" href="#max" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py class">
<dt id="django.db.models.Max">
<em class="property">class </em><code class="descname">Max</code>(<em><span class="n">expression</span></em>, <em><span class="n">output_field</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">filter</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="o">**</span><span class="n">extra</span></em>)<a class="reference internal" href="../../../_modules/django/db/models/aggregates/#Max"><span class="viewcode-link">[исходный код]</span></a><a class="headerlink" href="#django.db.models.Max" title="Ссылка на это определение">¶</a></dt>
<dd><p>Возвращает максимальное значение данного выражения.</p>
<ul class="simple">
<li>Псевдоним по умолчанию: <code class="docutils literal notranslate"><span class="pre">&lt;field&gt;__max</span></code></li>
<li>Тип возвращаемого значения: такой же, как у поля ввода, или <code class="docutils literal notranslate"><span class="pre">output_field</span></code>, если указано</li>
</ul>
</dd></dl>

</div>
<div class="section" id="s-min">
<span id="min"></span><h4><code class="docutils literal notranslate"><span class="pre">Min</span></code><a class="headerlink" href="#min" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py class">
<dt id="django.db.models.Min">
<em class="property">class </em><code class="descname">Min</code>(<em><span class="n">expression</span></em>, <em><span class="n">output_field</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">filter</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="o">**</span><span class="n">extra</span></em>)<a class="reference internal" href="../../../_modules/django/db/models/aggregates/#Min"><span class="viewcode-link">[исходный код]</span></a><a class="headerlink" href="#django.db.models.Min" title="Ссылка на это определение">¶</a></dt>
<dd><p>Возвращает минимальное значение данного выражения.</p>
<ul class="simple">
<li>Псевдоним по умолчанию: <code class="docutils literal notranslate"><span class="pre">&lt;field&gt;__min</span></code></li>
<li>Тип возвращаемого значения: такой же, как у поля ввода, или <code class="docutils literal notranslate"><span class="pre">output_field</span></code>, если указано</li>
</ul>
</dd></dl>

</div>
<div class="section" id="s-stddev">
<span id="stddev"></span><h4><code class="docutils literal notranslate"><span class="pre">StdDev</span></code><a class="headerlink" href="#stddev" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py class">
<dt id="django.db.models.StdDev">
<em class="property">class </em><code class="descname">StdDev</code>(<em><span class="n">expression</span></em>, <em><span class="n">output_field</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">sample</span><span class="o">=</span><span class="default_value">False</span></em>, <em><span class="n">filter</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="o">**</span><span class="n">extra</span></em>)<a class="reference internal" href="../../../_modules/django/db/models/aggregates/#StdDev"><span class="viewcode-link">[исходный код]</span></a><a class="headerlink" href="#django.db.models.StdDev" title="Ссылка на это определение">¶</a></dt>
<dd><p>Возвращает стандартное отклонение данных в предоставленном выражении.</p>
<ul class="simple">
<li>Псевдоним по умолчанию: <code class="docutils literal notranslate"><span class="pre">&lt;field&gt;__stddev</span></code></li>
<li>Тип возвращаемого значения: <code class="docutils literal notranslate"><span class="pre">float</span></code>, если на входе <code class="docutils literal notranslate"><span class="pre">int</span></code>, в остальном то же самое, что и поле ввода, или <code class="docutils literal notranslate"><span class="pre">output_field</span></code>, если он указан</li>
</ul>
<p>Имеет один необязательный аргумент:</p>
<dl class="py attribute">
<dt id="django.db.models.StdDev.sample">
<code class="descname">sample</code><a class="headerlink" href="#django.db.models.StdDev.sample" title="Ссылка на это определение">¶</a></dt>
<dd><p>По умолчанию <code class="docutils literal notranslate"><span class="pre">StdDev</span></code> возвращает стандартное отклонение популяции. Однако, если <code class="docutils literal notranslate"><span class="pre">sample=True</span></code>, возвращаемое значение будет стандартным отклонением выборки.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="s-sum">
<span id="sum"></span><h4><code class="docutils literal notranslate"><span class="pre">Sum</span></code><a class="headerlink" href="#sum" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py class">
<dt id="django.db.models.Sum">
<em class="property">class </em><code class="descname">Sum</code>(<em><span class="n">expression</span></em>, <em><span class="n">output_field</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">distinct</span><span class="o">=</span><span class="default_value">False</span></em>, <em><span class="n">filter</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="o">**</span><span class="n">extra</span></em>)<a class="reference internal" href="../../../_modules/django/db/models/aggregates/#Sum"><span class="viewcode-link">[исходный код]</span></a><a class="headerlink" href="#django.db.models.Sum" title="Ссылка на это определение">¶</a></dt>
<dd><p>Вычисляет сумму всех значений данного выражения.</p>
<ul class="simple">
<li>Псевдоним по умолчанию: <code class="docutils literal notranslate"><span class="pre">&lt;field&gt;__sum</span></code></li>
<li>Тип возвращаемого значения: такой же, как у поля ввода, или <code class="docutils literal notranslate"><span class="pre">output_field</span></code>, если указано</li>
</ul>
<p>Имеет один необязательный аргумент:</p>
<dl class="py attribute">
<dt id="django.db.models.Sum.distinct">
<code class="descname">distinct</code><a class="headerlink" href="#django.db.models.Sum.distinct" title="Ссылка на это определение">¶</a></dt>
<dd><p>Если <code class="docutils literal notranslate"><span class="pre">distinct=True</span></code>, <code class="docutils literal notranslate"><span class="pre">Sum</span></code> возвращает сумму уникальных значений. Это SQL-эквивалент <code class="docutils literal notranslate"><span class="pre">SUM(DISTINCT</span> <span class="pre">&lt;field&gt;)</span></code>. Значением по умолчанию является <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<div class="versionchanged">
<span class="title">Changed in Django 3.0:</span> <p>Добавлена поддержка <code class="docutils literal notranslate"><span class="pre">distinct=True</span></code>.</p>
</div>
</dd></dl>

</div>
<div class="section" id="s-variance">
<span id="variance"></span><h4><code class="docutils literal notranslate"><span class="pre">Variance</span></code><a class="headerlink" href="#variance" title="Ссылка на этот заголовок">¶</a></h4>
<dl class="py class">
<dt id="django.db.models.Variance">
<em class="property">class </em><code class="descname">Variance</code>(<em><span class="n">expression</span></em>, <em><span class="n">output_field</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">sample</span><span class="o">=</span><span class="default_value">False</span></em>, <em><span class="n">filter</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="o">**</span><span class="n">extra</span></em>)<a class="reference internal" href="../../../_modules/django/db/models/aggregates/#Variance"><span class="viewcode-link">[исходный код]</span></a><a class="headerlink" href="#django.db.models.Variance" title="Ссылка на это определение">¶</a></dt>
<dd><p>Возвращает дисперсию данных в предоставленном выражении.</p>
<ul class="simple">
<li>Псевдоним по умолчанию: <code class="docutils literal notranslate"><span class="pre">&lt;field&gt;__variance</span></code></li>
<li>Тип возвращаемого значения: <code class="docutils literal notranslate"><span class="pre">float</span></code>, если на входе <code class="docutils literal notranslate"><span class="pre">int</span></code>, в остальном то же самое, что и поле ввода, или <code class="docutils literal notranslate"><span class="pre">output_field</span></code>, если он указан</li>
</ul>
<p>Имеет один необязательный аргумент:</p>
<dl class="py attribute">
<dt id="django.db.models.Variance.sample">
<code class="descname">sample</code><a class="headerlink" href="#django.db.models.Variance.sample" title="Ссылка на это определение">¶</a></dt>
<dd><p>По умолчанию <code class="docutils literal notranslate"><span class="pre">Variance</span></code> возвращает дисперсию популяции. Однако, если <code class="docutils literal notranslate"><span class="pre">sample=True</span></code>, возвращаемым значением будет выборочная дисперсия.</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>
<div class="section" id="s-query-related-tools">
<span id="query-related-tools"></span><h2>Инструменты, связанные с запросами<a class="headerlink" href="#query-related-tools" title="Ссылка на этот заголовок">¶</a></h2>
<p>В этом разделе представлены справочные материалы по инструментам, связанным с запросами, которые не описаны в других документах.</p>
<div class="section" id="s-q-objects">
<span id="q-objects"></span><h3><code class="docutils literal notranslate"><span class="pre">Q()</span></code> объекты<a class="headerlink" href="#q-objects" title="Ссылка на этот заголовок">¶</a></h3>
<dl class="py class">
<dt id="django.db.models.Q">
<em class="property">class </em><code class="descname">Q</code><a class="reference internal" href="../../../_modules/django/db/models/query_utils/#Q"><span class="viewcode-link">[исходный код]</span></a><a class="headerlink" href="#django.db.models.Q" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Объект <code class="docutils literal notranslate"><span class="pre">Q()</span></code> представляет условие SQL, которое может использоваться в операциях, связанных с базой данных. Это похоже на то, как объект <a class="reference internal" href="../expressions/#django.db.models.F" title="django.db.models.F"><code class="xref py py-class docutils literal notranslate"><span class="pre">F()</span></code></a> представляет значение поля модели или аннотации. Они позволяют определять и повторно использовать условия и комбинировать их с помощью таких операторов, как <code class="docutils literal notranslate"><span class="pre">|</span></code> (<code class="docutils literal notranslate"><span class="pre">OR</span></code>) и <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> (<code class="docutils literal notranslate"><span class="pre">AND</span></code>). Смотрите <a class="reference internal" href="../../../topics/db/queries/#complex-lookups-with-q"><span class="std std-ref">Сложные поиски с объектами Q</span></a>.</p>
</div>
<div class="section" id="s-prefetch-objects">
<span id="prefetch-objects"></span><h3>Объекты <code class="docutils literal notranslate"><span class="pre">Prefetch()</span></code><a class="headerlink" href="#prefetch-objects" title="Ссылка на этот заголовок">¶</a></h3>
<dl class="py class">
<dt id="django.db.models.Prefetch">
<em class="property">class </em><code class="descname">Prefetch</code>(<em><span class="n">lookup</span></em>, <em><span class="n">queryset</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">to_attr</span><span class="o">=</span><span class="default_value">None</span></em>)<a class="reference internal" href="../../../_modules/django/db/models/query/#Prefetch"><span class="viewcode-link">[исходный код]</span></a><a class="headerlink" href="#django.db.models.Prefetch" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Объект <code class="docutils literal notranslate"><span class="pre">Prefetch()</span></code> может использоваться для управления операцией <a class="reference internal" href="#django.db.models.query.QuerySet.prefetch_related" title="django.db.models.query.QuerySet.prefetch_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prefetch_related()</span></code></a>.</p>
<p>Аргумент <code class="docutils literal notranslate"><span class="pre">lookup</span></code> описывает следующие отношения и работает так же, как и поиск на основе строк, передаваемый в <a class="reference internal" href="#django.db.models.query.QuerySet.prefetch_related" title="django.db.models.query.QuerySet.prefetch_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prefetch_related()</span></code></a>. Например:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="k">import</span> <span class="n">Prefetch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Question</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;choice_set&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">choice_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">&lt;QuerySet [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;</span>
<span class="go"># This will only execute two queries regardless of the number of Question</span>
<span class="go"># and Choice objects.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Question</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;choice_set&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">&lt;QuerySet [&lt;Question: What&#39;s up?&gt;]&gt;</span>
</pre></div>
</div>
<p>Аргумент <code class="docutils literal notranslate"><span class="pre">queryset</span></code> предоставляет базовый <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code> для данного поиска. Это полезно для дальнейшей фильтрации операции предварительной выборки или для вызова <a class="reference internal" href="#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">select_related()</span></code></a> из отношения предварительной выборки, следовательно, еще больше сокращая количество запросов:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">voted_choices</span> <span class="o">=</span> <span class="n">Choice</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">votes__gt</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">voted_choices</span>
<span class="go">&lt;QuerySet [&lt;Choice: The sky&gt;]&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prefetch</span> <span class="o">=</span> <span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;choice_set&#39;</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">voted_choices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Question</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="n">prefetch</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">choice_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">&lt;QuerySet [&lt;Choice: The sky&gt;]&gt;</span>
</pre></div>
</div>
<p>Аргумент <code class="docutils literal notranslate"><span class="pre">to_attr</span></code> устанавливает результат операции предварительной выборки в пользовательский атрибут:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">prefetch</span> <span class="o">=</span> <span class="n">Prefetch</span><span class="p">(</span><span class="s">&#39;choice_set&#39;</span><span class="p">,</span> <span class="n">queryset</span><span class="o">=</span><span class="n">voted_choices</span><span class="p">,</span> <span class="n">to_attr</span><span class="o">=</span><span class="s">&#39;voted_choices&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Question</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="n">prefetch</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">voted_choices</span>
<span class="go">[&lt;Choice: The sky&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Question</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">prefetch_related</span><span class="p">(</span><span class="n">prefetch</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">choice_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">&lt;QuerySet [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p class="last">При использовании <code class="docutils literal notranslate"><span class="pre">to_attr</span></code> предварительно выбранный результат сохраняется в списке. Это может обеспечить значительное улучшение скорости по сравнению с традиционными вызовами <code class="docutils literal notranslate"><span class="pre">prefetch_related</span></code>, которые хранят кэшированный результат в экземпляре <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>.</p>
</div>
</div>
<div class="section" id="s-prefetch-related-objects">
<span id="prefetch-related-objects"></span><h3><code class="docutils literal notranslate"><span class="pre">prefetch_related_objects()</span></code><a class="headerlink" href="#prefetch-related-objects" title="Ссылка на этот заголовок">¶</a></h3>
<dl class="py function">
<dt id="django.db.models.prefetch_related_objects">
<code class="descname">prefetch_related_objects</code>(<em><span class="n">model_instances</span></em>, <em><span class="o">*</span><span class="n">related_lookups</span></em>)<a class="reference internal" href="../../../_modules/django/db/models/query/#prefetch_related_objects"><span class="viewcode-link">[исходный код]</span></a><a class="headerlink" href="#django.db.models.prefetch_related_objects" title="Ссылка на это определение">¶</a></dt>
<dd></dd></dl>

<p>Предварительно выбирает данные поиски для повторяющихся экземпляров модели. Это полезно в коде, который получает список экземпляров модели, а не <code class="docutils literal notranslate"><span class="pre">QuerySet</span></code>; например, при извлечении моделей из кэша или создании их экземпляров вручную.</p>
<p>Передайте итерируемые экземпляры модели (все должны быть одного класса) и объекты поиска или <a class="reference internal" href="#django.db.models.Prefetch" title="django.db.models.Prefetch"><code class="xref py py-class docutils literal notranslate"><span class="pre">Prefetch</span></code></a>, для которых вы хотите выполнить предварительную выборку. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="k">import</span> <span class="n">prefetch_related_objects</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">restaurants</span> <span class="o">=</span> <span class="n">fetch_top_restaurants_from_cache</span><span class="p">()</span>  <span class="c"># A list of Restaurants</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prefetch_related_objects</span><span class="p">(</span><span class="n">restaurants</span><span class="p">,</span> <span class="s">&#39;pizzas__toppings&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>При использовании нескольких баз данных с <code class="docutils literal notranslate"><span class="pre">prefetch_related_objects</span></code> запрос предварительной выборки будет использовать базу данных, связанную с экземпляром модели. Это можно изменить, используя настраиваемый набор запросов в связанном поиске.</p>
</div>
<div class="section" id="s-filteredrelation-objects">
<span id="filteredrelation-objects"></span><h3>Объекты <code class="docutils literal notranslate"><span class="pre">FilteredRelation()</span></code><a class="headerlink" href="#filteredrelation-objects" title="Ссылка на этот заголовок">¶</a></h3>
<dl class="py class">
<dt id="django.db.models.FilteredRelation">
<em class="property">class </em><code class="descname">FilteredRelation</code>(<em><span class="n">relation_name</span></em>, <em><span class="o">*</span></em>, <em><span class="n">condition</span><span class="o">=</span><span class="default_value">Q()</span></em>)<a class="reference internal" href="../../../_modules/django/db/models/query_utils/#FilteredRelation"><span class="viewcode-link">[исходный код]</span></a><a class="headerlink" href="#django.db.models.FilteredRelation" title="Ссылка на это определение">¶</a></dt>
<dd><dl class="py attribute">
<dt id="django.db.models.FilteredRelation.relation_name">
<code class="descname">relation_name</code><a class="headerlink" href="#django.db.models.FilteredRelation.relation_name" title="Ссылка на это определение">¶</a></dt>
<dd><p>Имя поля, по которому вы хотите отфильтровать отношение.</p>
</dd></dl>

<dl class="py attribute">
<dt id="django.db.models.FilteredRelation.condition">
<code class="descname">condition</code><a class="headerlink" href="#django.db.models.FilteredRelation.condition" title="Ссылка на это определение">¶</a></dt>
<dd><p>A <a class="reference internal" href="#django.db.models.Q" title="django.db.models.Q"><code class="xref py py-class docutils literal notranslate"><span class="pre">Q</span></code></a> объект для управления фильтрацией.</p>
</dd></dl>

</dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">FilteredRelation</span></code> используется с <a class="reference internal" href="#django.db.models.query.QuerySet.annotate" title="django.db.models.query.QuerySet.annotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">annotate()</span></code></a> для создания предложения <code class="docutils literal notranslate"><span class="pre">ON</span></code> при выполнении <code class="docutils literal notranslate"><span class="pre">JOIN</span></code>. Он действует не на отношения по умолчанию, а на имя аннотации (<code class="docutils literal notranslate"><span class="pre">pizzas_vegetarian</span></code> в примере ниже).</p>
<p>Например, чтобы найти рестораны, в которых есть вегетарианская пицца с <code class="docutils literal notranslate"><span class="pre">'mozzarella'</span></code> в названии:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.db.models</span> <span class="k">import</span> <span class="n">FilteredRelation</span><span class="p">,</span> <span class="n">Q</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">pizzas_vegetarian</span><span class="o">=</span><span class="n">FilteredRelation</span><span class="p">(</span>
<span class="gp">... </span>       <span class="s">&#39;pizzas&#39;</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="n">Q</span><span class="p">(</span><span class="n">pizzas__vegetarian</span><span class="o">=</span><span class="k">True</span><span class="p">),</span>
<span class="gp">... </span>   <span class="p">),</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pizzas_vegetarian__name__icontains</span><span class="o">=</span><span class="s">&#39;mozzarella&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Если существует большое количество пицц, этот набор запросов работает лучше, чем:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pizzas__vegetarian</span><span class="o">=</span><span class="k">True</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">pizzas__name__icontains</span><span class="o">=</span><span class="s">&#39;mozzarella&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>потому что фильтрация в предложении <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> первого набора запросов будет работать только на вегетарианской пицце.</p>
<p><code class="docutils literal notranslate"><span class="pre">FilteredRelation</span></code> не поддерживает:</p>
<ul>
<li><p class="first">Условия, охватывающие реляционные поля. Например:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Restaurant</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">pizzas_with_toppings_startswith_n</span><span class="o">=</span><span class="n">FilteredRelation</span><span class="p">(</span>
<span class="gp">... </span>       <span class="s">&#39;pizzas__toppings&#39;</span><span class="p">,</span>
<span class="gp">... </span>       <span class="n">condition</span><span class="o">=</span><span class="n">Q</span><span class="p">(</span><span class="n">pizzas__toppings__name__startswith</span><span class="o">=</span><span class="s">&#39;n&#39;</span><span class="p">),</span>
<span class="gp">... </span>   <span class="p">),</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">FilteredRelation&#39;s condition doesn&#39;t support nested relations (got &#39;pizzas__toppings__name__startswith&#39;).</span>
</pre></div>
</div>
</li>
<li><p class="first"><a class="reference internal" href="#django.db.models.query.QuerySet.only" title="django.db.models.query.QuerySet.only"><code class="xref py py-meth docutils literal notranslate"><span class="pre">QuerySet.only()</span></code></a> и <a class="reference internal" href="#django.db.models.query.QuerySet.prefetch_related" title="django.db.models.query.QuerySet.prefetch_related"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prefetch_related()</span></code></a>.</p>
</li>
<li><p class="first"><a class="reference internal" href="../../contrib/contenttypes/#django.contrib.contenttypes.fields.GenericForeignKey" title="django.contrib.contenttypes.fields.GenericForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">GenericForeignKey</span></code></a> унаследован от родительской модели.</p>
</li>
</ul>
</div>
</div>
</div>

        </div>
    
    
    
        <div class="browse-horizontal">
            
                <div class="left"><a href="../instances/"><i class="icon icon-chevron-left"></i> Справочник по методам модели</a></div>
            
            
                <div class="right"><a href="../lookups/">Справочник по API поиска <i class="icon icon-chevron-right"></i></a></div>
            
        </div>
    


                <a href="#top" class="backtotop"><i class="icon icon-chevron-up"></i> Вернуться на верх</a>
            </div>
        </div>
    </div>


        <footer>
            <div class="df-footer">
                <div class="df-container">
                    &copy; Django.Fun 2017-2021 | 
                    Django.Fun не связан с Django Software Foundation. Django - зарегистрированная торговая марка Django Software Foundation. 
                </div>
            </div>
        </footer>
    </body>

    <script src="/static/js/df.js"></script>
    
    
        <!-- Yandex.Metrika counter --> <script type="text/javascript" > (function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter46974723 = new Ya.Metrika({ id:46974723, clickmap:true, trackLinks:true, accurateTrackBounce:true, webvisor:true }); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = "https://mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks"); </script> <noscript><div><img src="https://mc.yandex.ru/watch/46974723" style="position:absolute; left:-9999px;" alt="" /></div></noscript> <!-- /Yandex.Metrika counter -->
    
</html>
